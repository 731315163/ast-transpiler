



class binance(Exchange):
    def describe(self):
        return self.deepExtend(super().describe(),{
            'id': 'binance',
            'name': 'Binance',
            'countries': ['JP', 'MT'],
            'rateLimit': 50,
            'certified': True,
            'pro': True,
            'has': {
                'CORS': None,
                'spot': True,
                'margin': True,
                'swap': True,
                'future': True,
                'option': None,
                'addMargin': True,
                'borrowMargin': True,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'cancelOrders': None,
                'createDepositAddress': False,
                'createOrder': True,
                'createReduceOnlyOrder': True,
                'createStopLimitOrder': True,
                'createStopMarketOrder': False,
                'createStopOrder': True,
                'fetchAccounts': None,
                'fetchBalance': True,
                'fetchBidsAsks': True,
                'fetchBorrowInterest': True,
                'fetchBorrowRate': True,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': True,
                'fetchBorrowRates': False,
                'fetchBorrowRatesPerSymbol': False,
                'fetchCanceledOrders': False,
                'fetchClosedOrder': False,
                'fetchClosedOrders': 'emulated',
                'fetchCurrencies': True,
                'fetchDeposit': False,
                'fetchDepositAddress': True,
                'fetchDepositAddresses': False,
                'fetchDepositAddressesByNetwork': False,
                'fetchDeposits': True,
                'fetchFundingHistory': True,
                'fetchFundingRate': True,
                'fetchFundingRateHistory': True,
                'fetchFundingRates': True,
                'fetchIndexOHLCV': True,
                'fetchL3OrderBook': False,
                'fetchLedger': None,
                'fetchLeverage': False,
                'fetchLeverageTiers': True,
                'fetchMarketLeverageTiers': 'emulated',
                'fetchMarkets': True,
                'fetchMarkOHLCV': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenInterestHistory': True,
                'fetchOpenOrder': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': False,
                'fetchOrders': True,
                'fetchOrderTrades': True,
                'fetchPosition': None,
                'fetchPositions': True,
                'fetchPositionsRisk': True,
                'fetchPremiumIndexOHLCV': False,
                'fetchStatus': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFee': True,
                'fetchTradingFees': True,
                'fetchTradingLimits': None,
                'fetchTransactionFee': None,
                'fetchTransactionFees': True,
                'fetchTransactions': False,
                'fetchTransfers': True,
                'fetchWithdrawal': False,
                'fetchWithdrawals': True,
                'fetchWithdrawalWhitelist': False,
                'reduceMargin': True,
                'repayMargin': True,
                'setLeverage': True,
                'setMargin': False,
                'setMarginMode': True,
                'setPositionMode': True,
                'signIn': False,
                'transfer': True,
                'withdraw': True
            },
            'timeframes': {
                '1s': '1s',
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '8h': '8h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M'
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg',
                'test': {
                    'dapiPublic': 'https://testnet.binancefuture.com/dapi/v1',
                    'dapiPrivate': 'https://testnet.binancefuture.com/dapi/v1',
                    'vapiPublic': 'https://testnet.binanceops.com/vapi/v1',
                    'vapiPrivate': 'https://testnet.binanceops.com/vapi/v1',
                    'fapiPublic': 'https://testnet.binancefuture.com/fapi/v1',
                    'fapiPrivate': 'https://testnet.binancefuture.com/fapi/v1',
                    'fapiPrivateV2': 'https://testnet.binancefuture.com/fapi/v2',
                    'public': 'https://testnet.binance.vision/api/v3',
                    'private': 'https://testnet.binance.vision/api/v3',
                    'v1': 'https://testnet.binance.vision/api/v1'
                },
                'api': {
                    'wapi': 'https://api.binance.com/wapi/v3',
                    'sapi': 'https://api.binance.com/sapi/v1',
                    'sapiV3': 'https://api.binance.com/sapi/v3',
                    'dapiPublic': 'https://dapi.binance.com/dapi/v1',
                    'dapiPrivate': 'https://dapi.binance.com/dapi/v1',
                    'vapiPublic': 'https://vapi.binance.com/vapi/v1',
                    'vapiPrivate': 'https://vapi.binance.com/vapi/v1',
                    'dapiPrivateV2': 'https://dapi.binance.com/dapi/v2',
                    'dapiData': 'https://dapi.binance.com/futures/data',
                    'fapiPublic': 'https://fapi.binance.com/fapi/v1',
                    'fapiPrivate': 'https://fapi.binance.com/fapi/v1',
                    'fapiData': 'https://fapi.binance.com/futures/data',
                    'fapiPrivateV2': 'https://fapi.binance.com/fapi/v2',
                    'public': 'https://api.binance.com/api/v3',
                    'private': 'https://api.binance.com/api/v3',
                    'v1': 'https://api.binance.com/api/v1'
                },
                'www': 'https://www.binance.com',
                'referral': {
                    'url': 'https://accounts.binance.com/en/register?ref=D7YA7CLY',
                    'discount': 0.1
                },
                'doc': ['https://binance-docs.github.io/apidocs/spot/en'],
                'api_management': 'https://www.binance.com/en/usercenter/settings/api-management',
                'fees': 'https://www.binance.com/en/fee/schedule'
            },
            'depth': 1,
            'api': {
                'sapi': {
                    'get': {
                        'system/status': 0.1,
                        'accountSnapshot': 240,
                        'margin/asset': 1,
                        'margin/pair': 1,
                        'margin/allAssets': 0.1,
                        'margin/allPairs': 0.1,
                        'margin/priceIndex': 1,
                        'asset/assetDividend': 1,
                        'asset/dribblet': 0.1,
                        'asset/transfer': 0.1,
                        'asset/assetDetail': 0.1,
                        'asset/tradeFee': 0.1,
                        'margin/loan': 1,
                        'margin/repay': 1,
                        'margin/account': 1,
                        'margin/transfer': 0.1,
                        'margin/interestHistory': 0.1,
                        'margin/forceLiquidationRec': 0.1,
                        'margin/order': 1,
                        'margin/openOrders': 1,
                        'margin/allOrders': 20,
                        'margin/myTrades': 1,
                        'margin/maxBorrowable': 5,
                        'margin/maxTransferable': 5,
                        'margin/tradeCoeff': 1,
                        'margin/isolated/transfer': 0.1,
                        'margin/isolated/account': 1,
                        'margin/isolated/pair': 1,
                        'margin/isolated/allPairs': 1,
                        'margin/isolated/accountLimit': 0.1,
                        'margin/interestRateHistory': 0.1,
                        'margin/orderList': 1,
                        'margin/allOrderList': 20,
                        'margin/openOrderList': 1,
                        'margin/crossMarginData': {
                            'cost': 0.1,
                            'noCoin': 0.5
                        },
                        'margin/isolatedMarginData': {
                            'cost': 0.1,
                            'noCoin': 1
                        },
                        'margin/isolatedMarginTier': 0.1,
                        'margin/rateLimit/order': 2,
                        'margin/dribblet': 0.1,
                        'loan/income': 40,
                        'loan/ongoing/orders': 40,
                        'loan/ltv/adjustment/history': 40,
                        'loan/borrow/history': 2.6667,
                        'loan/repay/history': 40,
                        'fiat/orders': 600.03,
                        'fiat/payments': 0.1,
                        'futures/transfer': 1,
                        'futures/loan/borrow/history': 1,
                        'futures/loan/repay/history': 1,
                        'futures/loan/wallet': 1,
                        'futures/loan/adjustCollateral/history': 1,
                        'futures/loan/liquidationHistory': 1,
                        'rebate/taxQuery': 20.001,
                        'capital/config/getall': 1,
                        'capital/deposit/address': 1,
                        'capital/deposit/hisrec': 0.1,
                        'capital/deposit/subAddress': 0.1,
                        'capital/deposit/subHisrec': 0.1,
                        'capital/withdraw/history': 0.1,
                        'convert/tradeFlow': 0.6667,
                        'account/status': 0.1,
                        'account/apiTradingStatus': 0.1,
                        'account/apiRestrictions/ipRestriction': 0.1,
                        'bnbBurn': 0.1,
                        'sub-account/futures/account': 1,
                        'sub-account/futures/accountSummary': 0.1,
                        'sub-account/futures/positionRisk': 1,
                        'sub-account/futures/internalTransfer': 0.1,
                        'sub-account/list': 0.1,
                        'sub-account/margin/account': 1,
                        'sub-account/margin/accountSummary': 1,
                        'sub-account/spotSummary': 0.1,
                        'sub-account/status': 1,
                        'sub-account/sub/transfer/history': 0.1,
                        'sub-account/transfer/subUserHistory': 0.1,
                        'sub-account/universalTransfer': 0.1,
                        'managed-subaccount/asset': 0.1,
                        'managed-subaccount/accountSnapshot': 240,
                        'lending/daily/product/list': 0.1,
                        'lending/daily/userLeftQuota': 0.1,
                        'lending/daily/userRedemptionQuota': 0.1,
                        'lending/daily/token/position': 0.1,
                        'lending/union/account': 0.1,
                        'lending/union/purchaseRecord': 0.1,
                        'lending/union/redemptionRecord': 0.1,
                        'lending/union/interestHistory': 0.1,
                        'lending/project/list': 0.1,
                        'lending/project/position/list': 0.1,
                        'mining/pub/algoList': 0.1,
                        'mining/pub/coinList': 0.1,
                        'mining/worker/detail': 0.5,
                        'mining/worker/list': 0.5,
                        'mining/payment/list': 0.5,
                        'mining/statistics/user/status': 0.5,
                        'mining/statistics/user/list': 0.5,
                        'mining/payment/uid': 0.5,
                        'bswap/pools': 0.1,
                        'bswap/liquidity': {
                            'cost': 0.1,
                            'noPoolId': 1
                        },
                        'bswap/liquidityOps': 20.001,
                        'bswap/quote': 1.00005,
                        'bswap/swap': 20.001,
                        'bswap/poolConfigure': 1.00005,
                        'bswap/addLiquidityPreview': 1.00005,
                        'bswap/removeLiquidityPreview': 1.00005,
                        'bswap/unclaimedRewards': 6.667,
                        'bswap/claimedHistory': 6.667,
                        'blvt/tokenInfo': 0.1,
                        'blvt/subscribe/record': 0.1,
                        'blvt/redeem/record': 0.1,
                        'blvt/userLimit': 0.1,
                        'apiReferral/ifNewUser': 1,
                        'apiReferral/customization': 1,
                        'apiReferral/userCustomization': 1,
                        'apiReferral/rebate/recentRecord': 1,
                        'apiReferral/rebate/historicalRecord': 1,
                        'apiReferral/kickback/recentRecord': 1,
                        'apiReferral/kickback/historicalRecord': 1,
                        'broker/subAccountApi': 1,
                        'broker/subAccount': 1,
                        'broker/subAccountApi/commission/futures': 1,
                        'broker/subAccountApi/commission/coinFutures': 1,
                        'broker/info': 1,
                        'broker/transfer': 1,
                        'broker/transfer/futures': 1,
                        'broker/rebate/recentRecord': 1,
                        'broker/rebate/historicalRecord': 1,
                        'broker/subAccount/bnbBurn/status': 1,
                        'broker/subAccount/depositHist': 1,
                        'broker/subAccount/spotSummary': 1,
                        'broker/subAccount/marginSummary': 1,
                        'broker/subAccount/futuresSummary': 1,
                        'broker/rebate/futures/recentRecord': 1,
                        'broker/subAccountApi/ipRestriction': 1,
                        'broker/universalTransfer': 1,
                        'account/apiRestrictions': 0.1,
                        'c2c/orderMatch/listUserOrderHistory': 0.1,
                        'nft/history/transactions': 20.001,
                        'nft/history/deposit': 20.001,
                        'nft/history/withdraw': 20.001,
                        'nft/user/getAsset': 20.001,
                        'pay/transactions': 20.001,
                        'giftcard/verify': 0.1,
                        'giftcard/cryptography/rsa-public-key': 0.1,
                        'giftcard/buyCode/token-limit': 0.1,
                        'algo/futures/openOrders': 0.1,
                        'algo/futures/historicalOrders': 0.1,
                        'algo/futures/subOrders': 0.1,
                        'portfolio/account': 0.1,
                        'portfolio/collateralRate': 5,
                        'portfolio/pmLoan': 3.3335,
                        'staking/productList': 0.1,
                        'staking/position': 0.1,
                        'staking/stakingRecord': 0.1,
                        'staking/personalLeftQuota': 0.1
                    },
                    'post': {
                        'asset/dust': 1,
                        'asset/dust-btc': 0.1,
                        'asset/transfer': 0.1,
                        'asset/get-funding-asset': 0.1,
                        'asset/convert-transfer': 0.033335,
                        'asset/convert-transfer/queryByPage': 0.033335,
                        'account/disableFastWithdrawSwitch': 0.1,
                        'account/enableFastWithdrawSwitch': 0.1,
                        'capital/withdraw/apply': 0.1,
                        'margin/transfer': 1,
                        'margin/loan': 20.001,
                        'margin/repay': 20.001,
                        'margin/order': 0.040002,
                        'margin/order/oco': 0.040002,
                        'margin/isolated/transfer': 4.0002,
                        'margin/isolated/account': 2.0001,
                        'bnbBurn': 0.1,
                        'sub-account/virtualSubAccount': 0.1,
                        'sub-account/margin/transfer': 4.0002,
                        'sub-account/margin/enable': 0.1,
                        'sub-account/futures/enable': 0.1,
                        'sub-account/futures/transfer': 0.1,
                        'sub-account/futures/internalTransfer': 0.1,
                        'sub-account/transfer/subToSub': 0.1,
                        'sub-account/transfer/subToMaster': 0.1,
                        'sub-account/universalTransfer': 0.1,
                        'managed-subaccount/deposit': 0.1,
                        'managed-subaccount/withdraw': 0.1,
                        'userDataStream': 0.1,
                        'userDataStream/isolated': 0.1,
                        'futures/transfer': 0.1,
                        'lending/customizedFixed/purchase': 0.1,
                        'lending/daily/purchase': 0.1,
                        'lending/daily/redeem': 0.1,
                        'bswap/liquidityAdd': 60,
                        'bswap/liquidityRemove': 60,
                        'bswap/swap': 60,
                        'bswap/claimRewards': 6.667,
                        'blvt/subscribe': 0.1,
                        'blvt/redeem': 0.1,
                        'apiReferral/customization': 1,
                        'apiReferral/userCustomization': 1,
                        'apiReferral/rebate/historicalRecord': 1,
                        'apiReferral/kickback/historicalRecord': 1,
                        'broker/subAccount': 1,
                        'broker/subAccount/margin': 1,
                        'broker/subAccount/futures': 1,
                        'broker/subAccountApi': 1,
                        'broker/subAccountApi/permission': 1,
                        'broker/subAccountApi/commission': 1,
                        'broker/subAccountApi/commission/futures': 1,
                        'broker/subAccountApi/commission/coinFutures': 1,
                        'broker/transfer': 1,
                        'broker/transfer/futures': 1,
                        'broker/rebate/historicalRecord': 1,
                        'broker/subAccount/bnbBurn/spot': 1,
                        'broker/subAccount/bnbBurn/marginInterest': 1,
                        'broker/subAccount/blvt': 1,
                        'broker/subAccountApi/ipRestriction': 1,
                        'broker/subAccountApi/ipRestriction/ipList': 1,
                        'broker/universalTransfer': 1,
                        'broker/subAccountApi/permission/universalTransfer': 1,
                        'broker/subAccountApi/permission/vanillaOptions': 1,
                        'giftcard/createCode': 0.1,
                        'giftcard/redeemCode': 0.1,
                        'giftcard/buyCode': 0.1,
                        'algo/futures/newOrderVp': 20.001,
                        'algo/futures/newOrderTwap': 20.001,
                        'staking/purchase': 0.1,
                        'staking/redeem': 0.1,
                        'staking/setAutoStaking': 0.1,
                        'portfolio/repay': 20.001,
                        'loan/borrow': 40,
                        'loan/repay': 40,
                        'loan/adjust/ltv': 40
                    },
                    'put': {
                        'userDataStream': 0.1,
                        'userDataStream/isolated': 0.1
                    },
                    'delete': {
                        'margin/openOrders': 0.1,
                        'margin/order': 0.0066667,
                        'margin/orderList': 0.0066667,
                        'margin/isolated/account': 2.0001,
                        'userDataStream': 0.1,
                        'userDataStream/isolated': 0.1,
                        'broker/subAccountApi': 1,
                        'broker/subAccountApi/ipRestriction/ipList': 1,
                        'algo/futures/order': 0.1
                    }
                },
                'sapiV3': {
                    'get': {
                        'sub-account/assets': 1
                    },
                    'post': {
                        'asset/getUserAsset': 0.5
                    }
                },
                'wapi': {
                    'post': {
                        'withdraw': 1,
                        'sub-account/transfer': 1
                    },
                    'get': {
                        'depositHistory': 1,
                        'withdrawHistory': 1,
                        'depositAddress': 1,
                        'accountStatus': 1,
                        'systemStatus': 1,
                        'apiTradingStatus': 1,
                        'userAssetDribbletLog': 1,
                        'tradeFee': 1,
                        'assetDetail': 1,
                        'sub-account/list': 1,
                        'sub-account/transfer/history': 1,
                        'sub-account/assets': 1
                    }
                },
                'dapiPublic': {
                    'get': {
                        'ping': 1,
                        'time': 1,
                        'exchangeInfo': 1,
                        'depth': {
                            'cost': 2,
                            'byLimit': [[50, 2], [100, 5], [500, 10], [1000, 20]]
                        },
                        'trades': 5,
                        'historicalTrades': 20,
                        'aggTrades': 20,
                        'premiumIndex': 10,
                        'fundingRate': 1,
                        'klines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]
                        },
                        'continuousKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]
                        },
                        'indexPriceKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]
                        },
                        'markPriceKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]
                        },
                        'ticker/24hr': {
                            'cost': 1,
                            'noSymbol': 40
                        },
                        'ticker/price': {
                            'cost': 1,
                            'noSymbol': 2
                        },
                        'ticker/bookTicker': {
                            'cost': 1,
                            'noSymbol': 2
                        },
                        'openInterest': 1,
                        'pmExchangeInfo': 1
                    }
                },
                'dapiData': {
                    'get': {
                        'openInterestHist': 1,
                        'topLongShortAccountRatio': 1,
                        'topLongShortPositionRatio': 1,
                        'globalLongShortAccountRatio': 1,
                        'takerBuySellVol': 1,
                        'basis': 1
                    }
                },
                'dapiPrivate': {
                    'get': {
                        'positionSide/dual': 30,
                        'order': 1,
                        'openOrder': 1,
                        'openOrders': {
                            'cost': 1,
                            'noSymbol': 5
                        },
                        'allOrders': {
                            'cost': 20,
                            'noSymbol': 40
                        },
                        'balance': 1,
                        'account': 5,
                        'positionMargin/history': 1,
                        'positionRisk': 1,
                        'userTrades': {
                            'cost': 20,
                            'noSymbol': 40
                        },
                        'income': 20,
                        'leverageBracket': 1,
                        'forceOrders': {
                            'cost': 20,
                            'noSymbol': 50
                        },
                        'adlQuantile': 5,
                        'orderAmendment': 1,
                        'pmAccountInfo': 5
                    },
                    'post': {
                        'positionSide/dual': 1,
                        'order': 4,
                        'batchOrders': 5,
                        'countdownCancelAll': 10,
                        'leverage': 1,
                        'marginType': 1,
                        'positionMargin': 1,
                        'listenKey': 1
                    },
                    'put': {
                        'listenKey': 1,
                        'order': 1,
                        'batchOrders': 5
                    },
                    'delete': {
                        'order': 1,
                        'allOpenOrders': 1,
                        'batchOrders': 5,
                        'listenKey': 1
                    }
                },
                'dapiPrivateV2': {
                    'get': {
                        'leverageBracket': 1
                    }
                },
                'fapiPublic': {
                    'get': {
                        'ping': 1,
                        'time': 1,
                        'exchangeInfo': 1,
                        'depth': {
                            'cost': 2,
                            'byLimit': [[50, 2], [100, 5], [500, 10], [1000, 20]]
                        },
                        'trades': 5,
                        'historicalTrades': 20,
                        'aggTrades': 20,
                        'klines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]
                        },
                        'continuousKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]
                        },
                        'markPriceKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]
                        },
                        'indexPriceKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]
                        },
                        'fundingRate': 1,
                        'premiumIndex': 1,
                        'ticker/24hr': {
                            'cost': 1,
                            'noSymbol': 40
                        },
                        'ticker/price': {
                            'cost': 1,
                            'noSymbol': 2
                        },
                        'ticker/bookTicker': {
                            'cost': 1,
                            'noSymbol': 2
                        },
                        'openInterest': 1,
                        'indexInfo': 1,
                        'apiTradingStatus': {
                            'cost': 1,
                            'noSymbol': 10
                        },
                        'lvtKlines': 1,
                        'pmExchangeInfo': 1
                    }
                },
                'fapiData': {
                    'get': {
                        'openInterestHist': 1,
                        'topLongShortAccountRatio': 1,
                        'topLongShortPositionRatio': 1,
                        'globalLongShortAccountRatio': 1,
                        'takerlongshortRatio': 1
                    }
                },
                'fapiPrivate': {
                    'get': {
                        'forceOrders': {
                            'cost': 20,
                            'noSymbol': 50
                        },
                        'allOrders': 5,
                        'openOrder': 1,
                        'openOrders': 1,
                        'order': 1,
                        'account': 5,
                        'balance': 5,
                        'leverageBracket': 1,
                        'positionMargin/history': 1,
                        'positionRisk': 5,
                        'positionSide/dual': 30,
                        'userTrades': 5,
                        'income': 30,
                        'commissionRate': 20,
                        'apiTradingStatus': 1,
                        'multiAssetsMargin': 30,
                        'apiReferral/ifNewUser': 1,
                        'apiReferral/customization': 1,
                        'apiReferral/userCustomization': 1,
                        'apiReferral/traderNum': 1,
                        'apiReferral/overview': 1,
                        'apiReferral/tradeVol': 1,
                        'apiReferral/rebateVol': 1,
                        'apiReferral/traderSummary': 1,
                        'adlQuantile': 5,
                        'pmAccountInfo': 5
                    },
                    'post': {
                        'batchOrders': 5,
                        'positionSide/dual': 1,
                        'positionMargin': 1,
                        'marginType': 1,
                        'order': 4,
                        'leverage': 1,
                        'listenKey': 1,
                        'countdownCancelAll': 10,
                        'multiAssetsMargin': 1,
                        'apiReferral/customization': 1,
                        'apiReferral/userCustomization': 1
                    },
                    'put': {
                        'listenKey': 1
                    },
                    'delete': {
                        'batchOrders': 1,
                        'order': 1,
                        'allOpenOrders': 1,
                        'listenKey': 1
                    }
                },
                'fapiPrivateV2': {
                    'get': {
                        'account': 1,
                        'balance': 1,
                        'positionRisk': 1
                    }
                },
                'vapiPublic': {
                    'get': ['ping', 'time', 'optionInfo', 'exchangeInfo', 'index', 'ticker', 'mark', 'depth', 'klines', 'trades', 'historicalTrades']
                },
                'vapiPrivate': {
                    'get': ['account', 'position', 'order', 'openOrders', 'historyOrders', 'userTrades'],
                    'post': ['transfer', 'bill', 'order', 'batchOrders', 'userDataStream', 'openAccount'],
                    'put': ['userDataStream'],
                    'delete': ['order', 'batchOrders', 'allOpenOrders', 'userDataStream']
                },
                'public': {
                    'get': {
                        'ping': 1,
                        'time': 1,
                        'depth': {
                            'cost': 1,
                            'byLimit': [[100, 1], [500, 5], [1000, 10], [5000, 50]]
                        },
                        'trades': 1,
                        'aggTrades': 1,
                        'historicalTrades': 5,
                        'klines': 1,
                        'ticker/24hr': {
                            'cost': 1,
                            'noSymbol': 40
                        },
                        'ticker/price': {
                            'cost': 1,
                            'noSymbol': 2
                        },
                        'ticker/bookTicker': {
                            'cost': 1,
                            'noSymbol': 2
                        },
                        'exchangeInfo': 10
                    },
                    'put': {
                        'userDataStream': 1
                    },
                    'post': {
                        'userDataStream': 1
                    },
                    'delete': {
                        'userDataStream': 1
                    }
                },
                'private': {
                    'get': {
                        'allOrderList': 10,
                        'openOrderList': 3,
                        'orderList': 2,
                        'order': 2,
                        'openOrders': {
                            'cost': 3,
                            'noSymbol': 40
                        },
                        'allOrders': 10,
                        'account': 10,
                        'myTrades': 10,
                        'rateLimit/order': 20
                    },
                    'post': {
                        'order/oco': 1,
                        'order': 1,
                        'order/test': 1
                    },
                    'delete': {
                        'openOrders': 1,
                        'orderList': 1,
                        'order': 1
                    }
                }
            },
            'fees': {
                'trading': {
                    'feeSide': 'get',
                    'tierBased': False,
                    'percentage': True,
                    'taker': self.parseNumber('0.001'),
                    'maker': self.parseNumber('0.001')
                },
                'future': {
                    'trading': {
                        'feeSide': 'quote',
                        'tierBased': True,
                        'percentage': True,
                        'taker': self.parseNumber('0.000400'),
                        'maker': self.parseNumber('0.000200'),
                        'tiers': {
                            'taker': [[self.parseNumber('0'), self.parseNumber('0.000400')], [self.parseNumber('250'), self.parseNumber('0.000400')], [self.parseNumber('2500'), self.parseNumber('0.000350')], [self.parseNumber('7500'), self.parseNumber('0.000320')], [self.parseNumber('22500'), self.parseNumber('0.000300')], [self.parseNumber('50000'), self.parseNumber('0.000270')], [self.parseNumber('100000'), self.parseNumber('0.000250')], [self.parseNumber('200000'), self.parseNumber('0.000220')], [self.parseNumber('400000'), self.parseNumber('0.000200')], [self.parseNumber('750000'), self.parseNumber('0.000170')]],
                            'maker': [[self.parseNumber('0'), self.parseNumber('0.000200')], [self.parseNumber('250'), self.parseNumber('0.000160')], [self.parseNumber('2500'), self.parseNumber('0.000140')], [self.parseNumber('7500'), self.parseNumber('0.000120')], [self.parseNumber('22500'), self.parseNumber('0.000100')], [self.parseNumber('50000'), self.parseNumber('0.000080')], [self.parseNumber('100000'), self.parseNumber('0.000060')], [self.parseNumber('200000'), self.parseNumber('0.000040')], [self.parseNumber('400000'), self.parseNumber('0.000020')], [self.parseNumber('750000'), self.parseNumber('0')]]
                        }
                    }
                },
                'delivery': {
                    'trading': {
                        'feeSide': 'base',
                        'tierBased': True,
                        'percentage': True,
                        'taker': self.parseNumber('0.000500'),
                        'maker': self.parseNumber('0.000100'),
                        'tiers': {
                            'taker': [[self.parseNumber('0'), self.parseNumber('0.000500')], [self.parseNumber('250'), self.parseNumber('0.000450')], [self.parseNumber('2500'), self.parseNumber('0.000400')], [self.parseNumber('7500'), self.parseNumber('0.000300')], [self.parseNumber('22500'), self.parseNumber('0.000250')], [self.parseNumber('50000'), self.parseNumber('0.000240')], [self.parseNumber('100000'), self.parseNumber('0.000240')], [self.parseNumber('200000'), self.parseNumber('0.000240')], [self.parseNumber('400000'), self.parseNumber('0.000240')], [self.parseNumber('750000'), self.parseNumber('0.000240')]],
                            'maker': [[self.parseNumber('0'), self.parseNumber('0.000100')], [self.parseNumber('250'), self.parseNumber('0.000080')], [self.parseNumber('2500'), self.parseNumber('0.000050')], [self.parseNumber('7500'), self.parseNumber('0.0000030')], [self.parseNumber('22500'), self.parseNumber('0')], [self.parseNumber('50000'), self.parseNumber('-0.000050')], [self.parseNumber('100000'), self.parseNumber('-0.000060')], [self.parseNumber('200000'), self.parseNumber('-0.000070')], [self.parseNumber('400000'), self.parseNumber('-0.000080')], [self.parseNumber('750000'), self.parseNumber('-0.000090')]]
                        }
                    }
                },
                'option': {

                }
            },
            'commonCurrencies': {
                'BCC': 'BCC',
                'YOYO': 'YOYOW'
            },
            'precisionMode': DECIMAL_PLACES,
            'options': {
                'fetchCurrencies': True,
                'defaultTimeInForce': 'GTC',
                'defaultType': 'spot',
                'hasAlreadyAuthenticatedSuccessfully': False,
                'warnOnFetchOpenOrdersWithoutSymbol': True,
                'throwMarginModeAlreadySet': False,
                'fetchPositions': 'positionRisk',
                'recvWindow': 10 * 1000,
                'timeDifference': 0,
                'adjustForTimeDifference': False,
                'newOrderRespType': {
                    'market': 'FULL',
                    'limit': 'FULL'
                },
                'quoteOrderQty': True,
                'broker': {
                    'spot': 'x-R4BD3S82',
                    'margin': 'x-R4BD3S82',
                    'future': 'x-xcKtGhcu',
                    'delivery': 'x-xcKtGhcu'
                },
                'accountsByType': {
                    'main': 'MAIN',
                    'spot': 'MAIN',
                    'funding': 'FUNDING',
                    'margin': 'MARGIN',
                    'cross': 'MARGIN',
                    'future': 'UMFUTURE',
                    'delivery': 'CMFUTURE'
                },
                'accountsById': {
                    'MAIN': 'spot',
                    'FUNDING': 'funding',
                    'MARGIN': 'margin',
                    'UMFUTURE': 'future',
                    'CMFUTURE': 'delivery'
                },
                'networks': {
                    'ERC20': 'ETH',
                    'TRC20': 'TRX',
                    'BEP2': 'BNB',
                    'BEP20': 'BSC',
                    'OMNI': 'OMNI',
                    'EOS': 'EOS',
                    'SPL': 'SOL'
                },
                'reverseNetworks': {
                    'tronscan.org': 'TRC20',
                    'etherscan.io': 'ERC20',
                    'bscscan.com': 'BSC',
                    'explorer.binance.org': 'BEP2',
                    'bithomp.com': 'XRP',
                    'bloks.io': 'EOS',
                    'stellar.expert': 'XLM',
                    'blockchair.com/bitcoin': 'BTC',
                    'blockchair.com/bitcoin-cash': 'BCH',
                    'blockchair.com/ecash': 'XEC',
                    'explorer.litecoin.net': 'LTC',
                    'explorer.avax.network': 'AVAX',
                    'solscan.io': 'SOL',
                    'polkadot.subscan.io': 'DOT',
                    'dashboard.internetcomputer.org': 'ICP',
                    'explorer.chiliz.com': 'CHZ',
                    'cardanoscan.io': 'ADA',
                    'mainnet.theoan.com': 'AION',
                    'algoexplorer.io': 'ALGO',
                    'explorer.ambrosus.com': 'AMB',
                    'viewblock.io/zilliqa': 'ZIL',
                    'viewblock.io/arweave': 'AR',
                    'explorer.ark.io': 'ARK',
                    'atomscan.com': 'ATOM',
                    'www.mintscan.io': 'CTK',
                    'explorer.bitcoindiamond.org': 'BCD',
                    'btgexplorer.com': 'BTG',
                    'bts.ai': 'BTS',
                    'explorer.celo.org': 'CELO',
                    'explorer.nervos.org': 'CKB',
                    'cerebro.cortexlabs.ai': 'CTXC',
                    'chainz.cryptoid.info': 'VIA',
                    'explorer.dcrdata.org': 'DCR',
                    'digiexplorer.info': 'DGB',
                    'dock.subscan.io': 'DOCK',
                    'dogechain.info': 'DOGE',
                    'explorer.elrond.com': 'EGLD',
                    'blockscout.com': 'ETC',
                    'explore-fetchhub.fetch.ai': 'FET',
                    'filfox.info': 'FIL',
                    'fio.bloks.io': 'FIO',
                    'explorer.firo.org': 'FIRO',
                    'neoscan.io': 'NEO',
                    'ftmscan.com': 'FTM',
                    'explorer.gochain.io': 'GO',
                    'block.gxb.io': 'GXS',
                    'hash-hash.info': 'HBAR',
                    'www.hiveblockexplorer.com': 'HIVE',
                    'explorer.helium.com': 'HNT',
                    'tracker.icon.foundation': 'ICX',
                    'www.iostabc.com': 'IOST',
                    'explorer.iota.org': 'IOTA',
                    'iotexscan.io': 'IOTX',
                    'irishub.iobscan.io': 'IRIS',
                    'kava.mintscan.io': 'KAVA',
                    'scope.klaytn.com': 'KLAY',
                    'kmdexplorer.io': 'KMD',
                    'kusama.subscan.io': 'KSM',
                    'explorer.lto.network': 'LTO',
                    'polygonscan.com': 'POLYGON',
                    'explorer.ont.io': 'ONT',
                    'minaexplorer.com': 'MINA',
                    'nanolooker.com': 'NANO',
                    'explorer.nebulas.io': 'NAS',
                    'explorer.nbs.plus': 'NBS',
                    'explorer.nebl.io': 'NEBL',
                    'nulscan.io': 'NULS',
                    'nxscan.com': 'NXS',
                    'explorer.harmony.one': 'ONE',
                    'explorer.poa.network': 'POA',
                    'qtum.info': 'QTUM',
                    'explorer.rsk.co': 'RSK',
                    'www.oasisscan.com': 'ROSE',
                    'ravencoin.network': 'RVN',
                    'sc.tokenview.com': 'SC',
                    'secretnodes.com': 'SCRT',
                    'explorer.skycoin.com': 'SKY',
                    'steemscan.com': 'STEEM',
                    'explorer.stacks.co': 'STX',
                    'www.thetascan.io': 'THETA',
                    'scan.tomochain.com': 'TOMO',
                    'explore.vechain.org': 'VET',
                    'explorer.vite.net': 'VITE',
                    'www.wanscan.org': 'WAN',
                    'wavesexplorer.com': 'WAVES',
                    'wax.eosx.io': 'WAXP',
                    'waltonchain.pro': 'WTC',
                    'chain.nem.ninja': 'XEM',
                    'verge-blockchain.info': 'XVG',
                    'explorer.yoyow.org': 'YOYOW',
                    'explorer.zcha.in': 'ZEC',
                    'explorer.zensystem.io': 'ZEN'
                },
                'impliedNetworks': {
                    'ETH': {
                        'ERC20': 'ETH'
                    },
                    'TRX': {
                        'TRC20': 'TRX'
                    }
                },
                'legalMoney': {
                    'MXN': True,
                    'UGX': True,
                    'SEK': True,
                    'CHF': True,
                    'VND': True,
                    'AED': True,
                    'DKK': True,
                    'KZT': True,
                    'HUF': True,
                    'PEN': True,
                    'PHP': True,
                    'USD': True,
                    'TRY': True,
                    'EUR': True,
                    'NGN': True,
                    'PLN': True,
                    'BRL': True,
                    'ZAR': True,
                    'KES': True,
                    'ARS': True,
                    'RUB': True,
                    'AUD': True,
                    'NOK': True,
                    'CZK': True,
                    'GBP': True,
                    'UAH': True,
                    'GHS': True,
                    'HKD': True,
                    'CAD': True,
                    'INR': True,
                    'JPY': True,
                    'NZD': True
                }
            },
            'exceptions': {
                'exact': {
                    'System is under maintenance.': OnMaintenance,
                    'System abnormality': ExchangeError,
                    'You are not authorized to execute this request.': PermissionDenied,
                    'API key does not exist': AuthenticationError,
                    'Order would trigger immediately.': OrderImmediatelyFillable,
                    'Stop price would trigger immediately.': OrderImmediatelyFillable,
                    'Order would immediately match and take.': OrderImmediatelyFillable,
                    'Account has insufficient balance for requested action.': InsufficientFunds,
                    'Rest API trading is not enabled.': ExchangeNotAvailable,
                    'You don\'t have permission.': PermissionDenied,
                    'Market is closed.': ExchangeNotAvailable,
                    'Too many requests. Please try again later.': DDoSProtection,
                    'This action disabled is on this account.': AccountSuspended,
                    'This type of sub-account exceeds the maximum number limit': BadRequest,
                    'This symbol is not permitted for this account.': PermissionDenied,
                    '-1000': ExchangeNotAvailable,
                    '-1001': ExchangeNotAvailable,
                    '-1002': AuthenticationError,
                    '-1003': RateLimitExceeded,
                    '-1004': DDoSProtection,
                    '-1005': PermissionDenied,
                    '-1006': BadResponse,
                    '-1007': RequestTimeout,
                    '-1010': BadResponse,
                    '-1011': PermissionDenied,
                    '-1013': InvalidOrder,
                    '-1014': InvalidOrder,
                    '-1015': RateLimitExceeded,
                    '-1016': ExchangeNotAvailable,
                    '-1020': BadRequest,
                    '-1021': InvalidNonce,
                    '-1022': AuthenticationError,
                    '-1023': BadRequest,
                    '-1099': AuthenticationError,
                    '-1100': BadRequest,
                    '-1101': BadRequest,
                    '-1102': BadRequest,
                    '-1103': BadRequest,
                    '-1104': BadRequest,
                    '-1105': BadRequest,
                    '-1106': BadRequest,
                    '-1108': BadRequest,
                    '-1109': AuthenticationError,
                    '-1110': BadRequest,
                    '-1111': BadRequest,
                    '-1112': InvalidOrder,
                    '-1113': BadRequest,
                    '-1114': BadRequest,
                    '-1115': BadRequest,
                    '-1116': BadRequest,
                    '-1117': BadRequest,
                    '-1118': BadRequest,
                    '-1119': BadRequest,
                    '-1120': BadRequest,
                    '-1121': BadSymbol,
                    '-1125': AuthenticationError,
                    '-1127': BadRequest,
                    '-1128': BadRequest,
                    '-1130': BadRequest,
                    '-1131': BadRequest,
                    '-1136': BadRequest,
                    '-2008': AuthenticationError,
                    '-2010': ExchangeError,
                    '-2011': OrderNotFound,
                    '-2013': OrderNotFound,
                    '-2014': AuthenticationError,
                    '-2015': AuthenticationError,
                    '-2016': BadRequest,
                    '-2018': InsufficientFunds,
                    '-2019': InsufficientFunds,
                    '-2020': OrderNotFillable,
                    '-2021': OrderImmediatelyFillable,
                    '-2022': InvalidOrder,
                    '-2023': InsufficientFunds,
                    '-2024': InsufficientFunds,
                    '-2025': InvalidOrder,
                    '-2026': InvalidOrder,
                    '-2027': InvalidOrder,
                    '-2028': InsufficientFunds,
                    '-3000': ExchangeError,
                    '-3001': AuthenticationError,
                    '-3002': BadSymbol,
                    '-3003': BadRequest,
                    '-3004': ExchangeError,
                    '-3005': InsufficientFunds,
                    '-3006': InsufficientFunds,
                    '-3007': ExchangeError,
                    '-3008': InsufficientFunds,
                    '-3009': BadRequest,
                    '-3010': BadRequest,
                    '-3011': BadRequest,
                    '-3012': InsufficientFunds,
                    '-3013': BadRequest,
                    '-3014': AccountSuspended,
                    '-3015': BadRequest,
                    '-3016': BadRequest,
                    '-3017': ExchangeError,
                    '-3018': AccountSuspended,
                    '-3019': AccountSuspended,
                    '-3020': InsufficientFunds,
                    '-3021': BadRequest,
                    '-3022': AccountSuspended,
                    '-3023': BadRequest,
                    '-3024': ExchangeError,
                    '-3025': BadRequest,
                    '-3026': BadRequest,
                    '-3027': BadSymbol,
                    '-3028': BadSymbol,
                    '-3029': ExchangeError,
                    '-3036': AccountSuspended,
                    '-3037': ExchangeError,
                    '-3038': BadRequest,
                    '-3041': InsufficientFunds,
                    '-3042': BadRequest,
                    '-3043': BadRequest,
                    '-3044': DDoSProtection,
                    '-3045': ExchangeError,
                    '-3999': ExchangeError,
                    '-4001': BadRequest,
                    '-4002': BadRequest,
                    '-4003': BadRequest,
                    '-4004': AuthenticationError,
                    '-4005': RateLimitExceeded,
                    '-4006': BadRequest,
                    '-4007': BadRequest,
                    '-4008': BadRequest,
                    '-4010': BadRequest,
                    '-4011': BadRequest,
                    '-4012': BadRequest,
                    '-4013': AuthenticationError,
                    '-4014': PermissionDenied,
                    '-4015': ExchangeError,
                    '-4016': PermissionDenied,
                    '-4017': PermissionDenied,
                    '-4018': BadSymbol,
                    '-4019': BadSymbol,
                    '-4021': BadRequest,
                    '-4022': BadRequest,
                    '-4023': ExchangeError,
                    '-4024': InsufficientFunds,
                    '-4025': InsufficientFunds,
                    '-4026': InsufficientFunds,
                    '-4027': ExchangeError,
                    '-4028': BadRequest,
                    '-4029': BadRequest,
                    '-4030': ExchangeError,
                    '-4031': ExchangeError,
                    '-4032': ExchangeError,
                    '-4033': BadRequest,
                    '-4034': ExchangeError,
                    '-4035': PermissionDenied,
                    '-4036': BadRequest,
                    '-4037': ExchangeError,
                    '-4038': ExchangeError,
                    '-4039': BadRequest,
                    '-4040': BadRequest,
                    '-4041': ExchangeError,
                    '-4042': ExchangeError,
                    '-4043': BadRequest,
                    '-4044': BadRequest,
                    '-4045': ExchangeError,
                    '-4046': AuthenticationError,
                    '-4047': BadRequest,
                    '-5001': BadRequest,
                    '-5002': InsufficientFunds,
                    '-5003': InsufficientFunds,
                    '-5004': BadRequest,
                    '-5005': InsufficientFunds,
                    '-5006': BadRequest,
                    '-5007': BadRequest,
                    '-5008': InsufficientFunds,
                    '-5009': BadRequest,
                    '-5010': ExchangeError,
                    '-5011': BadRequest,
                    '-5012': ExchangeError,
                    '-5013': InsufficientFunds,
                    '-5021': BadRequest,
                    '-6001': BadRequest,
                    '-6003': BadRequest,
                    '-6004': ExchangeError,
                    '-6005': InvalidOrder,
                    '-6006': BadRequest,
                    '-6007': BadRequest,
                    '-6008': BadRequest,
                    '-6009': RateLimitExceeded,
                    '-6011': BadRequest,
                    '-6012': InsufficientFunds,
                    '-6013': ExchangeError,
                    '-6014': BadRequest,
                    '-6015': BadRequest,
                    '-6016': BadRequest,
                    '-6017': BadRequest,
                    '-6018': BadRequest,
                    '-6019': AuthenticationError,
                    '-6020': BadRequest,
                    '-7001': BadRequest,
                    '-7002': BadRequest,
                    '-9000': InsufficientFunds,
                    '-10017': BadRequest,
                    '-11008': InsufficientFunds,
                    '-12014': RateLimitExceeded,
                    '-13000': BadRequest,
                    '-13001': BadRequest,
                    '-13002': BadRequest,
                    '-13003': BadRequest,
                    '-13004': BadRequest,
                    '-13005': BadRequest,
                    '-13006': InvalidOrder,
                    '-13007': AuthenticationError,
                    '-21001': BadRequest,
                    '-21002': BadRequest,
                    '-21003': BadRequest,
                    '100001003': BadRequest
                },
                'broad': {
                    'has no operation privilege': PermissionDenied,
                    'MAX_POSITION': InvalidOrder
                }
            }
        })

    def costToPrecision(self, symbol, cost):
        return self.decimalToPrecision(cost,TRUNCATE,self.markets[symbol]['precision']['quote'],self.precisionMode,self.paddingMode)

    def currencyToPrecision(self, code, fee, networkCode):
        if self.safeValue(self.currencies[code],'precision') != None:
            return self.decimalToPrecision(fee,TRUNCATE,self.currencies[code]['precision'],self.precisionMode,self.paddingMode)
        else:
            return self.numberToString(fee)

    def nonce(self):
        return self.milliseconds() - self.options['timeDifference']

    async def fetchTime(self, params):
        defaultType = self.safeString2(self.options,'fetchTime','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        query = self.omit(params,'type')
        method = 'publicGetTime'
        if type == 'future':
            method = 'fapiPublicGetTime'
        elif type == 'delivery':
            method = 'dapiPublicGetTime'

        response = await getattr(self, method)(query)
        return self.safeInteger(response,'serverTime')

    async def fetchCurrencies(self, params):
        fetchCurrenciesEnabled = self.safeValue(self.options,'fetchCurrencies')
        if notfetchCurrenciesEnabled:
            return None

        if notself.checkRequiredCredentials(False):
            return None

        apiBackup = self.safeString(self.urls,'apiBackup')
        if apiBackup != None:
            return None

        response = await (self).sapiGetCapitalConfigGetall(params)
        result = {

        }
        for i in range(0, len(response)):
            entry = response[i]
            id = self.safeString(entry,'coin')
            name = self.safeString(entry,'name')
            code = self.safeCurrencyCode(id)
            precision = None
            isWithdrawEnabled = True
            isDepositEnabled = True
            networkList = self.safeValue(entry,'networkList',[])
            fees = {

            }
            fee = None
            for j in range(0, len(networkList)):
                networkItem = networkList[j]
                network = self.safeString(networkItem,'network')
                withdrawFee = self.safeNumber(networkItem,'withdrawFee')
                depositEnable = self.safeValue(networkItem,'depositEnable')
                withdrawEnable = self.safeValue(networkItem,'withdrawEnable')
                isDepositEnabled = isDepositEnabled or depositEnable
                isWithdrawEnabled = isWithdrawEnabled or withdrawEnable
                fees[network] = withdrawFee
                isDefault = self.safeValue(networkItem,'isDefault')
                if isDefault or (fee == None):
                    fee = withdrawFee

            trading = self.safeValue(entry,'trading')
            active = (isWithdrawEnabled and isDepositEnabled and trading)
            result[code] = {
                'id': id,
                'name': name,
                'code': code,
                'precision': precision,
                'info': entry,
                'active': active,
                'deposit': isDepositEnabled,
                'withdraw': isWithdrawEnabled,
                'networks': networkList,
                'fee': fee,
                'fees': fees,
                'limits': self.limits
            }
        return result

    async def fetchMarkets(self, params):
        defaultType = self.safeString2(self.options,'fetchMarkets','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        query = self.omit(params,'type')
        spot = (type == 'spot')
        margin = (type == 'margin')
        future = (type == 'future')
        delivery = (type == 'delivery')
        if (notspot) and (notmargin) and (notfuture) and (notdelivery):
            raise ExchangeError(self.id + ' does not support \'' + type + '\' type, set exchange.options['defaultType'] to 'spot', 'margin', 'delivery' or 'future'')

        method = 'publicGetExchangeInfo'
        if future:
            method = 'fapiPublicGetExchangeInfo'
        elif delivery:
            method = 'dapiPublicGetExchangeInfo'

        response = await getattr(self, method)(query)
        if self.options['adjustForTimeDifference']:
            await self.loadTimeDifference()

        markets = self.safeValue(response,'symbols',[])
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = self.safeString(market,'symbol')
            lowercaseId = self.safeStringLower(market,'symbol')
            baseId = self.safeString(market,'baseAsset')
            quoteId = self.safeString(market,'quoteAsset')
            settleId = self.safeString(market,'marginAsset')
            base = self.safeCurrencyCode(baseId)
            quote = self.safeCurrencyCode(quoteId)
            settle = self.safeCurrencyCode(settleId)
            contract = future or delivery
            contractType = self.safeString(market,'contractType')
            idSymbol = contract and (contractType != 'PERPETUAL')
            symbol = None
            expiry = None
            if idSymbol:
                symbol = id
                expiry = self.safeInteger(market,'deliveryDate')
            else:
                symbol = base + '/' + quote
            filters = self.safeValue(market,'filters',[])
            filtersByType = self.indexBy(filters,'filterType')
            status = self.safeString2(market,'status','contractStatus')
            contractSize = None
            fees = self.fees
            linear = None
            inverse = None
            if contract:
                contractSize = self.safeNumber(market,'contractSize',self.parseNumber('1'))
                fees = self.fees[type]
                linear = settle == quote
                inverse = settle == base

            active = (status == 'TRADING')
            if spot:
                permissions = self.safeValue(market,'permissions',[])
                for j in range(0, len(permissions)):
                    if permissions[j] == 'TRD_GRP_003':
                        active = False
                        break


            isMarginTradingAllowed = self.safeValue(market,'isMarginTradingAllowed',False)
            entry = {
                'id': id,
                'lowercaseId': lowercaseId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': settle,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': settleId,
                'type': type,
                'spot': spot,
                'margin': spot and isMarginTradingAllowed,
                'swap': future,
                'future': future,
                'delivery': delivery,
                'option': False,
                'active': active,
                'contract': contract,
                'linear': linear,
                'inverse': inverse,
                'taker': fees['trading']['taker'],
                'maker': fees['trading']['maker'],
                'contractSize': contractSize,
                'expiry': expiry,
                'expiryDatetime': self.iso8601(expiry),
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': self.safeInteger(market,'quantityPrecision'),
                    'price': self.safeInteger(market,'pricePrecision'),
                    'base': self.safeInteger(market,'baseAssetPrecision'),
                    'quote': self.safeInteger(market,'quotePrecision')
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None
                    },
                    'amount': {
                        'min': None,
                        'max': None
                    },
                    'price': {
                        'min': None,
                        'max': None
                    },
                    'cost': {
                        'min': None,
                        'max': None
                    }
                },
                'info': market
            }
            if 'PRICE_FILTER' in filtersByType:
                filter = self.safeValue(filtersByType,'PRICE_FILTER',{

                })
                entry['limits']['price'] = {
                    'min': self.safeNumber(filter,'minPrice'),
                    'max': self.safeNumber(filter,'maxPrice')
                }
                entry['precision']['price'] = self.precisionFromString(filter['tickSize'])

            if 'LOT_SIZE' in filtersByType:
                filter = self.safeValue(filtersByType,'LOT_SIZE',{

                })
                stepSize = self.safeString(filter,'stepSize')
                entry['precision']['amount'] = self.precisionFromString(stepSize)
                entry['limits']['amount'] = {
                    'min': self.safeNumber(filter,'minQty'),
                    'max': self.safeNumber(filter,'maxQty')
                }

            if 'MARKET_LOT_SIZE' in filtersByType:
                filter = self.safeValue(filtersByType,'MARKET_LOT_SIZE',{

                })
                entry['limits']['market'] = {
                    'min': self.safeNumber(filter,'minQty'),
                    'max': self.safeNumber(filter,'maxQty')
                }

            if 'MIN_NOTIONAL' in filtersByType:
                filter = self.safeValue(filtersByType,'MIN_NOTIONAL',{

                })
                entry['limits']['cost']['min'] = self.safeNumber2(filter,'minNotional','notional')

            result.append(entry)
        return result

    def parseBalanceHelper(self, entry):
        account = self.account()
        account['used'] = self.safeString(entry,'locked')
        account['free'] = self.safeString(entry,'free')
        account['total'] = self.safeString(entry,'totalAsset')
        return account

    def parseBalance(self, response, type, marginMode):
        result = {
            'info': response
        }
        timestamp = None
        isolated = marginMode == 'isolated'
        if ((type == 'spot') or (type == 'margin') or (marginMode == 'cross')) and notisolated:
            timestamp = self.safeInteger(response,'updateTime')
            balances = self.safeValue2(response,'balances','userAssets',[])
            for i in range(0, len(balances)):
                balance = balances[i]
                currencyId = self.safeString(balance,'asset')
                code = self.safeCurrencyCode(currencyId)
                account = self.account()
                account['free'] = self.safeString(balance,'free')
                account['used'] = self.safeString(balance,'locked')
                result[code] = account
        elif isolated:
            assets = self.safeValue(response,'assets')
            for i in range(0, len(assets)):
                asset = assets[i]
                marketId = self.safeValue(asset,'symbol')
                symbol = self.safeSymbol(marketId)
                base = self.safeValue(asset,'baseAsset',{

                })
                quote = self.safeValue(asset,'quoteAsset',{

                })
                baseCode = self.safeCurrencyCode(self.safeString(base,'asset'))
                quoteCode = self.safeCurrencyCode(self.safeString(quote,'asset'))
                subResult = {

                }
                subResult[baseCode] = self.parseBalanceHelper(base)
                subResult[quoteCode] = self.parseBalanceHelper(quote)
                result[symbol] = self.safeBalance(subResult)
        elif type == 'savings':
            positionAmountVos = self.safeValue(response,'positionAmountVos',[])
            for i in range(0, len(positionAmountVos)):
                entry = positionAmountVos[i]
                currencyId = self.safeString(entry,'asset')
                code = self.safeCurrencyCode(currencyId)
                account = self.account()
                usedAndTotal = self.safeString(entry,'amount')
                account['total'] = usedAndTotal
                account['used'] = usedAndTotal
                result[code] = account
        elif type == 'funding':
            for i in range(0, len(response)):
                entry = response[i]
                account = self.account()
                currencyId = self.safeString(entry,'asset')
                code = self.safeCurrencyCode(currencyId)
                account['free'] = self.safeString(entry,'free')
                frozen = self.safeString(entry,'freeze')
                withdrawing = self.safeString(entry,'withdrawing')
                locked = self.safeString(entry,'locked')
                account['used'] = Precise.stringAdd(frozen,Precise.stringAdd(locked,withdrawing))
                result[code] = account
        else:
            balances = response
            if notisinstance(response, list):
                balances = self.safeValue(response,'assets',[])

            for i in range(0, len(balances)):
                balance = balances[i]
                currencyId = self.safeString(balance,'asset')
                code = self.safeCurrencyCode(currencyId)
                account = self.account()
                account['free'] = self.safeString(balance,'availableBalance')
                account['used'] = self.safeString(balance,'initialMargin')
                account['total'] = self.safeString2(balance,'marginBalance','balance')
                result[code] = account
        result['timestamp'] = timestamp
        result['datetime'] = self.iso8601(timestamp)
        return result if isolated else self.safeBalance(result)

    async def fetchBalance(self, params):
        await self.loadMarkets()
        defaultType = self.safeString2(self.options,'fetchBalance','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        [marginMode, query] = self.handleMarginModeAndParams('fetchBalance',params)
        method = 'privateGetAccount'
        request = {

        }
        if type == 'future':
            options = self.safeValue(self.options,type,{

            })
            fetchBalanceOptions = self.safeValue(options,'fetchBalance',{

            })
            method = self.safeString(fetchBalanceOptions,'method','fapiPrivateV2GetAccount')
        elif type == 'delivery':
            options = self.safeValue(self.options,type,{

            })
            fetchBalanceOptions = self.safeValue(options,'fetchBalance',{

            })
            method = self.safeString(fetchBalanceOptions,'method','dapiPrivateGetAccount')
        elif type == 'margin' or marginMode == 'cross':
            method = 'sapiGetMarginAccount'
        elif type == 'savings':
            method = 'sapiGetLendingUnionAccount'
        elif type == 'funding':
            method = 'sapiPostAssetGetFundingAsset'
        elif marginMode == 'isolated':
            method = 'sapiGetMarginIsolatedAccount'
            paramSymbols = self.safeValue(params,'symbols')
            if paramSymbols != None:
                symbols = ''
                if self.isArray(paramSymbols):
                    symbols = self.marketId(paramSymbols[0])
                    for i in range(1, len(paramSymbols)):
                        symbol = paramSymbols[i]
                        id = self.marketId(symbol)
                        symbols += ',' + id
                else:
                    symbols = paramSymbols
                request['symbols'] = symbols


        requestParams = self.omit(query,['type', 'symbols'])
        response = await getattr(self, method)(self.extend(request,requestParams))
        return self.parseBalance(response,type,marginMode)

    async def fetchOrderBook(self, symbol, limit, params):
        await self.loadMarkets()
        market = self.market(symbol)
        request = {
            'symbol': market['id']
        }
        if limit != None:
            request['limit'] = limit

        method = 'publicGetDepth'
        if market['linear']:
            method = 'fapiPublicGetDepth'
        elif market['inverse']:
            method = 'dapiPublicGetDepth'

        response = await getattr(self, method)(self.extend(request,params))
        timestamp = self.safeInteger(response,'T')
        orderbook = self.parseOrderBook(response,symbol,timestamp)
        orderbook['nonce'] = self.safeInteger(response,'lastUpdateId')
        return orderbook

    def parseTicker(self, ticker, market):
        timestamp = self.safeInteger(ticker,'closeTime')
        marketId = self.safeString(ticker,'symbol')
        symbol = self.safeSymbol(marketId,market)
        last = self.safeString(ticker,'lastPrice')
        isCoinm = ('baseVolume' in ticker)
        baseVolume = None
        quoteVolume = None
        if isCoinm:
            baseVolume = self.safeString(ticker,'baseVolume')
            quoteVolume = self.safeString(ticker,'volume')
        else:
            baseVolume = self.safeString(ticker,'volume')
            quoteVolume = self.safeString(ticker,'quoteVolume')
        return self.safeTicker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safeString(ticker,'highPrice'),
            'low': self.safeString(ticker,'lowPrice'),
            'bid': self.safeString(ticker,'bidPrice'),
            'bidVolume': self.safeString(ticker,'bidQty'),
            'ask': self.safeString(ticker,'askPrice'),
            'askVolume': self.safeString(ticker,'askQty'),
            'vwap': self.safeString(ticker,'weightedAvgPrice'),
            'open': self.safeString(ticker,'openPrice'),
            'close': last,
            'last': last,
            'previousClose': self.safeString(ticker,'prevClosePrice'),
            'change': self.safeString(ticker,'priceChange'),
            'percentage': self.safeString(ticker,'priceChangePercent'),
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker
        },market)

    async def fetchStatus(self, params):
        response = await (self).sapiGetSystemStatus(params)
        statusRaw = self.safeString(response,'status')
        return {
            'status': self.safeString({
                '0': 'ok',
                '1': 'maintenance'
            },statusRaw,statusRaw),
            'updated': None,
            'eta': None,
            'url': None,
            'info': response
        }

    async def fetchTicker(self, symbol, params):
        await self.loadMarkets()
        market = self.market(symbol)
        request = {
            'symbol': market['id']
        }
        method = 'publicGetTicker24hr'
        if market['linear']:
            method = 'fapiPublicGetTicker24hr'
        elif market['inverse']:
            method = 'dapiPublicGetTicker24hr'

        response = await getattr(self, method)(self.extend(request,params))
        if isinstance(response, list):
            firstTicker = self.safeValue(response,0,{

            })
            return self.parseTicker(firstTicker,market)

        return self.parseTicker(response,market)

    async def fetchBidsAsks(self, symbols, params):
        await self.loadMarkets()
        defaultType = self.safeString2(self.options,'fetchBidsAsks','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        query = self.omit(params,'type')
        method = None
        if type == 'future':
            method = 'fapiPublicGetTickerBookTicker'
        elif type == 'delivery':
            method = 'dapiPublicGetTickerBookTicker'
        else:
            method = 'publicGetTickerBookTicker'
        response = await getattr(self, method)(query)
        return self.parseTickers(response,symbols)

    async def fetchTickers(self, symbols, params):
        await self.loadMarkets()
        defaultType = self.safeString2(self.options,'fetchTickers','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        query = self.omit(params,'type')
        defaultMethod = None
        if type == 'future':
            defaultMethod = 'fapiPublicGetTicker24hr'
        elif type == 'delivery':
            defaultMethod = 'dapiPublicGetTicker24hr'
        else:
            defaultMethod = 'publicGetTicker24hr'
        method = self.safeString(self.options,'fetchTickersMethod',defaultMethod)
        response = await getattr(self, method)(query)
        return self.parseTickers(response,symbols)

    def parseOHLCV(self, ohlcv, market):
        return [self.safeInteger(ohlcv,0), self.safeNumber(ohlcv,1), self.safeNumber(ohlcv,2), self.safeNumber(ohlcv,3), self.safeNumber(ohlcv,4), self.safeNumber(ohlcv,5)]

    async def fetchOHLCV(self, symbol, timeframe, since, limit, params):
        await self.loadMarkets()
        market = self.market(symbol)
        defaultLimit = 500
        maxLimit = 1500
        price = self.safeString(params,'price')
        until = self.safeInteger(params,'until')
        params = self.omit(params,['price', 'until'])
        limit = defaultLimit if (limit == None) else Math.min(limit,maxLimit)
        request = {
            'interval': self.timeframes[timeframe],
            'limit': limit
        }
        if price == 'index':
            request['pair'] = market['id']
        else:
            request['symbol'] = market['id']
        if since != None:
            request['startTime'] = since
            if market['inverse']:
                if since > 0:
                    duration = self.parseTimeframe(timeframe)
                    endTime = self.sum(since,limit * duration * 1000 - 1)
                    now = self.milliseconds()
                    request['endTime'] = Math.min(now,endTime)



        if until != None:
            request['endTime'] = until

        method = 'publicGetKlines'
        if price == 'mark':
            if market['inverse']:
                method = 'dapiPublicGetMarkPriceKlines'
            else:
                method = 'fapiPublicGetMarkPriceKlines'
        elif price == 'index':
            if market['inverse']:
                method = 'dapiPublicGetIndexPriceKlines'
            else:
                method = 'fapiPublicGetIndexPriceKlines'
        elif market['linear']:
            method = 'fapiPublicGetKlines'
        elif market['inverse']:
            method = 'dapiPublicGetKlines'

        response = await getattr(self, method)(self.extend(request,params))
        return self.parseOHLCVs(response,market,timeframe,since,limit)

    def parseTrade(self, trade, market):
        if 'isDustTrade' in trade:
            return self.parseDustTrade(trade,market)

        timestamp = self.safeInteger2(trade,'T','time')
        price = self.safeString2(trade,'p','price')
        amount = self.safeString2(trade,'q','qty')
        cost = self.safeString2(trade,'quoteQty','baseQty')
        marketId = self.safeString(trade,'symbol')
        symbol = self.safeSymbol(marketId,market)
        id = self.safeString2(trade,'t','a')
        id = self.safeString2(trade,'id','tradeId',id)
        side = None
        orderId = self.safeString(trade,'orderId')
        buyerMaker = self.safeValue2(trade,'m','isBuyerMaker')
        takerOrMaker = None
        if buyerMaker != None:
            side = 'sell' if buyerMaker else 'buy'
            takerOrMaker = 'taker'
        elif 'side' in trade:
            side = self.safeStringLower(trade,'side')
        else:
            if 'isBuyer' in trade:
                side = 'buy' if trade['isBuyer'] else 'sell'

        fee = None
        if 'commission' in trade:
            fee = {
                'cost': self.safeString(trade,'commission'),
                'currency': self.safeCurrencyCode(self.safeString(trade,'commissionAsset'))
            }

        if 'isMaker' in trade:
            takerOrMaker = 'maker' if trade['isMaker'] else 'taker'

        if 'maker' in trade:
            takerOrMaker = 'maker' if trade['maker'] else 'taker'

        return self.safeTrade({
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': orderId,
            'type': None,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee
        },market)

    async def fetchTrades(self, symbol, since, limit, params):
        await self.loadMarkets()
        market = self.market(symbol)
        request = {
            'symbol': market['id']
        }
        [type, query] = self.handleMarketTypeAndParams('fetchTrades',market,params)
        defaultMethod = None
        if type == 'future':
            if market['linear']:
                defaultMethod = 'fapiPublicGetAggTrades'
            elif market['inverse']:
                defaultMethod = 'dapiPublicGetAggTrades'

        elif type == 'delivery':
            defaultMethod = 'dapiPublicGetAggTrades'
        else:
            defaultMethod = 'publicGetAggTrades'
        method = self.safeString(self.options,'fetchTradesMethod',defaultMethod)
        if method == 'publicGetAggTrades':
            if type == 'future':
                if market['linear']:
                    method = 'fapiPublicGetAggTrades'
                elif market['inverse']:
                    method = 'dapiPublicGetAggTrades'

            elif type == 'delivery':
                method = 'dapiPublicGetAggTrades'

        elif method == 'publicGetHistoricalTrades':
            if type == 'future':
                if market['linear']:
                    method = 'fapiPublicGetHistoricalTrades'
                elif market['inverse']:
                    method = 'dapiPublicGetHistoricalTrades'

            elif type == 'delivery':
                method = 'dapiPublicGetHistoricalTrades'


        if since != None:
            request['startTime'] = since
            request['endTime'] = self.sum(since,3600000)

        if limit != None:
            request['limit'] = limit

        response = await getattr(self, method)(self.extend(request,query))
        return self.parseTrades(response,market,since,limit)

    def parseOrderStatus(self, status):
        statuses = {
            'NEW': 'open',
            'PARTIALLY_FILLED': 'open',
            'FILLED': 'closed',
            'CANCELED': 'canceled',
            'PENDING_CANCEL': 'canceling',
            'REJECTED': 'rejected',
            'EXPIRED': 'expired'
        }
        return self.safeString(statuses,status,status)

    def parseOrder(self, order, market):
        status = self.parseOrderStatus(self.safeString(order,'status'))
        marketId = self.safeString(order,'symbol')
        symbol = self.safeSymbol(marketId,market)
        filled = self.safeString(order,'executedQty','0')
        timestamp = None
        lastTradeTimestamp = None
        if 'time' in order:
            timestamp = self.safeInteger(order,'time')
        elif 'transactTime' in order:
            timestamp = self.safeInteger(order,'transactTime')
        elif 'updateTime' in order:
            if status == 'open':
                if Precise.stringGt(filled,'0'):
                    lastTradeTimestamp = self.safeInteger(order,'updateTime')
                else:
                    timestamp = self.safeInteger(order,'updateTime')


        average = self.safeString(order,'avgPrice')
        price = self.safeString(order,'price')
        amount = self.safeString(order,'origQty')
        cost = self.safeString2(order,'cummulativeQuoteQty','cumQuote')
        cost = self.safeString(order,'cumBase',cost)
        id = self.safeString(order,'orderId')
        type = self.safeStringLower(order,'type')
        side = self.safeStringLower(order,'side')
        fills = self.safeValue(order,'fills',[])
        clientOrderId = self.safeString(order,'clientOrderId')
        timeInForce = self.safeString(order,'timeInForce')
        if timeInForce == 'GTX':
            timeInForce = 'PO'

        postOnly = (type == 'limit_maker') or (timeInForce == 'PO')
        if type == 'limit_maker':
            type = 'limit'

        stopPriceString = self.safeString(order,'stopPrice')
        stopPrice = self.parseNumber(self.omitZero(stopPriceString))
        return self.safeOrder({
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'symbol': symbol,
            'type': type,
            'timeInForce': timeInForce,
            'postOnly': postOnly,
            'reduceOnly': self.safeValue(order,'reduceOnly'),
            'side': side,
            'price': price,
            'stopPrice': stopPrice,
            'amount': amount,
            'cost': cost,
            'average': average,
            'filled': filled,
            'remaining': None,
            'status': status,
            'fee': None,
            'trades': fills
        },market)

    async def createOrder(self, symbol, type, side, amount, price, params):
        await self.loadMarkets()
        market = self.market(symbol)
        defaultType = self.safeString2(self.options,'createOrder','defaultType','spot')
        marketType = self.safeString(params,'type',defaultType)
        clientOrderId = self.safeString2(params,'newClientOrderId','clientOrderId')
        postOnly = self.safeValue(params,'postOnly',False)
        reduceOnly = self.safeValue(params,'reduceOnly')
        [marginMode, query] = self.handleMarginModeAndParams('createOrder',params)
        if reduceOnly != None:
            if (marketType != 'future') and (marketType != 'delivery'):
                raise InvalidOrder(self.id + ' createOrder() does not support reduceOnly for ' + marketType + ' orders, reduceOnly orders are supported for future and delivery markets only')


        method = 'privatePostOrder'
        if marketType == 'future':
            method = 'fapiPrivatePostOrder'
        elif marketType == 'delivery':
            method = 'dapiPrivatePostOrder'
        elif marketType == 'margin' or marginMode != None:
            method = 'sapiPostMarginOrder'

        if market['spot'] or marketType == 'margin':
            test = self.safeValue(query,'test',False)
            if test:
                method += 'Test'

            if postOnly:
                type = 'LIMIT_MAKER'


        initialUppercaseType = type.upper()
        uppercaseType = initialUppercaseType
        stopPrice = self.safeNumber(query,'stopPrice')
        if stopPrice != None:
            if uppercaseType == 'MARKET':
                uppercaseType = 'STOP_MARKET' if market['contract'] else 'STOP_LOSS'
            elif uppercaseType == 'LIMIT':
                uppercaseType = 'STOP' if market['contract'] else 'STOP_LOSS_LIMIT'


        validOrderTypes = self.safeValue(market['info'],'orderTypes')
        if notself.inArray(uppercaseType,validOrderTypes):
            if initialUppercaseType != uppercaseType:
                raise InvalidOrder(self.id + ' stopPrice parameter is not allowed for ' + symbol + ' ' + type + ' orders')
            else:
                raise InvalidOrder(self.id + ' ' + type + ' is not a valid order type for the ' + symbol + ' market')

        request = {
            'symbol': market['id'],
            'type': uppercaseType,
            'side': side.upper()
        }
        if marginMode == 'isolated':
            request['isIsolated'] = True

        if clientOrderId == None:
            broker = self.safeValue(self.options,'broker')
            if broker != None:
                brokerId = self.safeString(broker,marketType)
                if brokerId != None:
                    request['newClientOrderId'] = brokerId + self.uuid22()


        else:
            request['newClientOrderId'] = clientOrderId
        if (marketType == 'spot') or (marketType == 'margin'):
            request['newOrderRespType'] = self.safeValue(self.options['newOrderRespType'],type,'RESULT')
        else:
            request['newOrderRespType'] = 'RESULT'
        timeInForceIsRequired = False
        priceIsRequired = False
        stopPriceIsRequired = False
        quantityIsRequired = False
        if uppercaseType == 'MARKET':
            if market['spot']:
                quoteOrderQty = self.safeValue(self.options,'quoteOrderQty',True)
                if quoteOrderQty:
                    quoteOrderQty = self.safeValue2(query,'quoteOrderQty','cost')
                    precision = market['precision']['price']
                    if quoteOrderQty != None:
                        request['quoteOrderQty'] = self.decimalToPrecision(quoteOrderQty,TRUNCATE,precision,self.precisionMode)
                    elif price != None:
                        amountString = self.numberToString(amount)
                        priceString = self.numberToString(price)
                        quoteOrderQuantity = Precise.stringMul(amountString,priceString)
                        request['quoteOrderQty'] = self.decimalToPrecision(quoteOrderQuantity,TRUNCATE,precision,self.precisionMode)
                    else:
                        quantityIsRequired = True
                else:
                    quantityIsRequired = True
            else:
                quantityIsRequired = True
        elif uppercaseType == 'LIMIT':
            priceIsRequired = True
            timeInForceIsRequired = True
            quantityIsRequired = True
        elif (uppercaseType == 'STOP_LOSS') or (uppercaseType == 'TAKE_PROFIT'):
            stopPriceIsRequired = True
            quantityIsRequired = True
            if market['linear'] or market['inverse']:
                priceIsRequired = True

        elif (uppercaseType == 'STOP_LOSS_LIMIT') or (uppercaseType == 'TAKE_PROFIT_LIMIT'):
            quantityIsRequired = True
            stopPriceIsRequired = True
            priceIsRequired = True
            timeInForceIsRequired = True
        elif uppercaseType == 'LIMIT_MAKER':
            priceIsRequired = True
            quantityIsRequired = True
        elif uppercaseType == 'STOP':
            quantityIsRequired = True
            stopPriceIsRequired = True
            priceIsRequired = True
        elif (uppercaseType == 'STOP_MARKET') or (uppercaseType == 'TAKE_PROFIT_MARKET'):
            closePosition = self.safeValue(query,'closePosition')
            if closePosition == None:
                quantityIsRequired = True

            stopPriceIsRequired = True
        elif uppercaseType == 'TRAILING_STOP_MARKET':
            quantityIsRequired = True
            callbackRate = self.safeNumber(query,'callbackRate')
            if callbackRate == None:
                raise InvalidOrder(self.id + ' createOrder() requires a callbackRate extra param for a ' + type + ' order')


        if quantityIsRequired:
            request['quantity'] = self.amountToPrecision(symbol,amount)

        if priceIsRequired:
            if price == None:
                raise InvalidOrder(self.id + ' createOrder() requires a price argument for a ' + type + ' order')

            request['price'] = self.priceToPrecision(symbol,price)

        if timeInForceIsRequired:
            request['timeInForce'] = self.options['defaultTimeInForce']

        if stopPriceIsRequired:
            if stopPrice == None:
                raise InvalidOrder(self.id + ' createOrder() requires a stopPrice extra param for a ' + type + ' order')
            else:
                request['stopPrice'] = self.priceToPrecision(symbol,stopPrice)

        requestParams = self.omit(params,['quoteOrderQty', 'cost', 'stopPrice', 'test', 'type', 'newClientOrderId', 'clientOrderId', 'postOnly'])
        response = await getattr(self, method)(self.extend(request,requestParams))
        return self.parseOrder(response,market)

    async def fetchOrder(self, id, symbol, params):
        if symbol == None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol argument')

        await self.loadMarkets()
        market = self.market(symbol)
        defaultType = self.safeString2(self.options,'fetchOrder','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        [marginMode, query] = self.handleMarginModeAndParams('fetchOrder',params)
        request = {
            'symbol': market['id']
        }
        method = 'privateGetOrder'
        if type == 'future':
            method = 'fapiPrivateGetOrder'
        elif type == 'delivery':
            method = 'dapiPrivateGetOrder'
        elif type == 'margin' or marginMode != None:
            method = 'sapiGetMarginOrder'
            if marginMode == 'isolated':
                request['isIsolated'] = True


        clientOrderId = self.safeValue2(params,'origClientOrderId','clientOrderId')
        if clientOrderId != None:
            request['origClientOrderId'] = clientOrderId
        else:
            request['orderId'] = id
        requestParams = self.omit(query,['type', 'clientOrderId', 'origClientOrderId'])
        response = await getattr(self, method)(self.extend(request,requestParams))
        return self.parseOrder(response,market)

    async def fetchOrders(self, symbol, since, limit, params):
        if symbol == None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a symbol argument')

        await self.loadMarkets()
        market = self.market(symbol)
        defaultType = self.safeString2(self.options,'fetchOrders','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        [marginMode, query] = self.handleMarginModeAndParams('fetchOrders',params)
        request = {
            'symbol': market['id']
        }
        method = 'privateGetAllOrders'
        if type == 'future':
            method = 'fapiPrivateGetAllOrders'
        elif type == 'delivery':
            method = 'dapiPrivateGetAllOrders'
        elif type == 'margin' or marginMode != None:
            method = 'sapiGetMarginAllOrders'
            if marginMode == 'isolated':
                request['isIsolated'] = True


        if since != None:
            request['startTime'] = since

        if limit != None:
            request['limit'] = limit

        requestParams = self.omit(query,['type'])
        response = await getattr(self, method)(self.extend(request,requestParams))
        return self.parseOrders(response,market,since,limit)

    async def fetchOpenOrders(self, symbol, since, limit, params):
        await self.loadMarkets()
        market = None
        type = None
        request = {

        }
        [marginMode, query] = self.handleMarginModeAndParams('fetchOpenOrders',params)
        if symbol != None:
            market = self.market(symbol)
            request['symbol'] = market['id']
            defaultType = self.safeString2(self.options,'fetchOpenOrders','defaultType','spot')
            marketType = market['type'] if ('type' in market) else defaultType
            type = self.safeString(query,'type',marketType)
        elif self.options['warnOnFetchOpenOrdersWithoutSymbol']:
            symbols = self.symbols
            numSymbols = len(symbols)
            fetchOpenOrdersRateLimit = self.parseToInt(numSymbols / 2)
            raise ExchangeError(self.id + ' fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per ' + str(fetchOpenOrdersRateLimit) + ' seconds. Do not call this method frequently to avoid ban. Set ' + self.id + '.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')
        else:
            defaultType = self.safeString2(self.options,'fetchOpenOrders','defaultType','spot')
            type = self.safeString(query,'type',defaultType)
        requestParams = self.omit(query,'type')
        method = 'privateGetOpenOrders'
        if type == 'future':
            method = 'fapiPrivateGetOpenOrders'
        elif type == 'delivery':
            method = 'dapiPrivateGetOpenOrders'
        elif type == 'margin' or marginMode != None:
            method = 'sapiGetMarginOpenOrders'
            if marginMode == 'isolated':
                request['isIsolated'] = True
                if symbol == None:
                    raise ArgumentsRequired(self.id + ' fetchOpenOrders() requires a symbol argument for isolated markets')



        response = await getattr(self, method)(self.extend(request,requestParams))
        return self.parseOrders(response,market,since,limit)

    async def fetchClosedOrders(self, symbol, since, limit, params):
        orders = await self.fetchOrders(symbol,since,limit,params)
        return self.filterBy(orders,'status','closed')

    async def cancelOrder(self, id, symbol, params):
        if symbol == None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')

        await self.loadMarkets()
        market = self.market(symbol)
        defaultType = self.safeString2(self.options,'cancelOrder','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        origClientOrderId = self.safeValue2(params,'origClientOrderId','clientOrderId')
        [marginMode, query] = self.handleMarginModeAndParams('cancelOrder',params)
        request = {
            'symbol': market['id']
        }
        if origClientOrderId == None:
            request['orderId'] = id
        else:
            request['origClientOrderId'] = origClientOrderId
        method = 'privateDeleteOrder'
        if type == 'future':
            method = 'fapiPrivateDeleteOrder'
        elif type == 'delivery':
            method = 'dapiPrivateDeleteOrder'
        elif type == 'margin' or marginMode != None:
            method = 'sapiDeleteMarginOrder'
            if marginMode == 'isolated':
                request['isIsolated'] = True
                if symbol == None:
                    raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument for isolated markets')



        requestParams = self.omit(query,['type', 'origClientOrderId', 'clientOrderId'])
        response = await getattr(self, method)(self.extend(request,requestParams))
        return self.parseOrder(response,market)

    async def cancelAllOrders(self, symbol, params):
        if symbol == None:
            raise ArgumentsRequired(self.id + ' cancelAllOrders () requires a symbol argument')

        await self.loadMarkets()
        market = self.market(symbol)
        request = {
            'symbol': market['id']
        }
        defaultType = self.safeString2(self.options,'cancelAllOrders','defaultType','spot')
        type = self.safeString(params,'type',defaultType)
        params = self.omit(params,['type'])
        [marginMode, query] = self.handleMarginModeAndParams('cancelAllOrders',params)
        method = 'privateDeleteOpenOrders'
        if type == 'future':
            method = 'fapiPrivateDeleteAllOpenOrders'
        elif type == 'delivery':
            method = 'dapiPrivateDeleteAllOpenOrders'
        elif type == 'margin' or marginMode != None:
            method = 'sapiDeleteMarginOpenOrders'
            if marginMode == 'isolated':
                request['isIsolated'] = True


        response = await getattr(self, method)(self.extend(request,query))
        if isinstance(response, list):
            return self.parseOrders(response,market)
        else:
            return response

    async def fetchOrderTrades(self, id, symbol, since, limit, params):
        if symbol == None:
            raise ArgumentsRequired(self.id + ' fetchOrderTrades() requires a symbol argument')

        await self.loadMarkets()
        market = self.market(symbol)
        type = self.safeString(params,'type',market['type'])
        params = self.omit(params,'type')
        if type != 'spot':
            raise NotSupported(self.id + ' fetchOrderTrades() supports spot markets only')

        request = {
            'orderId': id
        }
        return await self.fetchMyTrades(symbol,since,limit,self.extend(request,params))

    async def fetchMyTrades(self, symbol, since, limit, params):
        if symbol == None:
            raise ArgumentsRequired(self.id + ' fetchMyTrades() requires a symbol argument')

        await self.loadMarkets()
        market = self.market(symbol)
        request = {
            'symbol': market['id']
        }
        type = self.safeString(params,'type',market['type'])
        params = self.omit(params,'type')
        method = None
        linear = (type == 'future')
        inverse = (type == 'delivery')
        marginMode = None
        [marginMode, params] = self.handleMarginModeAndParams('fetchMyTrades',params)
        if type == 'spot' or type == 'margin':
            method = 'privateGetMyTrades'
            if (market['type'] == 'margin') or (marginMode != None):
                method = 'sapiGetMarginMyTrades'
                if marginMode == 'isolated':
                    request['isIsolated'] = True


        elif linear:
            method = 'fapiPrivateGetUserTrades'
        elif inverse:
            method = 'dapiPrivateGetUserTrades'

        endTime = self.safeInteger2(params,'until','endTime')
        if since != None:
            startTime = parseInt(since)
            request['startTime'] = startTime
            currentTimestamp = self.milliseconds()
            oneWeek = 7 * 24 * 60 * 60 * 1000
            if (currentTimestamp - startTime) >= oneWeek:
                if (endTime == None) and linear:
                    endTime = self.sum(startTime,oneWeek)
                    endTime = Math.min(endTime,currentTimestamp)



        if endTime != None:
            request['endTime'] = endTime
            params = self.omit(params,['endTime', 'until'])

        if limit != None:
            if type == 'future' or type == 'delivery':
                limit = Math.min(limit,1000)

            request['limit'] = limit

        response = await getattr(self, method)(self.extend(request,params))
        return self.parseTrades(response,market,since,limit)

    async def fetchMyDustTrades(self, symbol, since, limit, params):
        await self.loadMarkets()
        request = {

        }
        if since != None:
            request['startTime'] = since
            request['endTime'] = self.sum(since,7776000000)

        response = await (self).sapiGetAssetDribblet(self.extend(request,params))
        results = self.safeValue(response,'userAssetDribblets',[])
        rows = self.safeInteger(response,'total',0)
        data = []
        for i in range(0, rows):
            logs = self.safeValue(results[i],'userAssetDribbletDetails',[])
            for j in range(0, len(logs)):
                logs[j]['isDustTrade'] = True
                data.append(logs[j])
        trades = self.parseTrades(data,None,since,limit)
        return self.filterBySinceLimit(trades,since,limit)

    def parseDustTrade(self, trade, market):
        orderId = self.safeString(trade,'transId')
        timestamp = self.safeInteger(trade,'operateTime')
        currencyId = self.safeString(trade,'fromAsset')
        tradedCurrency = self.safeCurrencyCode(currencyId)
        bnb = self.currency('BNB')
        earnedCurrency = bnb['code']
        applicantSymbol = earnedCurrency + '/' + tradedCurrency
        tradedCurrencyIsQuote = False
        if applicantSymbol in self.markets:
            tradedCurrencyIsQuote = True

        feeCostString = self.safeString(trade,'serviceChargeAmount')
        fee = {
            'currency': earnedCurrency,
            'cost': self.parseNumber(feeCostString)
        }
        symbol = None
        amountString = None
        costString = None
        side = None
        if tradedCurrencyIsQuote:
            symbol = applicantSymbol
            amountString = self.safeString(trade,'transferedAmount')
            costString = self.safeString(trade,'amount')
            side = 'buy'
        else:
            symbol = tradedCurrency + '/' + earnedCurrency
            amountString = self.safeString(trade,'amount')
            costString = self.safeString(trade,'transferedAmount')
            side = 'sell'
        priceString = None
        if costString != None:
            if amountString:
                priceString = Precise.stringDiv(costString,amountString)


        id = None
        amount = self.parseNumber(amountString)
        price = self.parseNumber(priceString)
        cost = self.parseNumber(costString)
        type = None
        takerOrMaker = None
        return {
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': orderId,
            'type': type,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'amount': amount,
            'price': price,
            'cost': cost,
            'fee': fee,
            'info': trade
        }

    async def fetchDeposits(self, code, since, limit, params):
        await self.loadMarkets()
        currency = None
        response = None
        request = {

        }
        legalMoney = self.safeValue(self.options,'legalMoney',{

        })
        until = self.safeInteger(params,'until')
        if code in legalMoney:
            if code != None:
                currency = self.currency(code)

            request['transactionType'] = 0
            if since != None:
                request['beginTime'] = since

            if until != None:
                request['endTime'] = until

            raw = await (self).sapiGetFiatOrders(self.extend(request,params))
            response = self.safeValue(raw,'data')
        else:
            if code != None:
                currency = self.currency(code)
                request['coin'] = currency['id']

            if since != None:
                request['startTime'] = since
                endTime = self.sum(since,7776000000)
                if until != None:
                    endTime = Math.min(endTime,until)

                request['endTime'] = endTime

            if limit != None:
                request['limit'] = limit

            response = await (self).sapiGetCapitalDepositHisrec(self.extend(request,params))
        return self.parseTransactions(response,currency,since,limit)

    async def fetchWithdrawals(self, code, since, limit, params):
        await self.loadMarkets()
        legalMoney = self.safeValue(self.options,'legalMoney',{

        })
        request = {

        }
        response = None
        currency = None
        if code in legalMoney:
            if code != None:
                currency = self.currency(code)

            request['transactionType'] = 1
            if since != None:
                request['beginTime'] = since

            raw = await (self).sapiGetFiatOrders(self.extend(request,params))
            response = self.safeValue(raw,'data')
        else:
            if code != None:
                currency = self.currency(code)
                request['coin'] = currency['id']

            if since != None:
                request['startTime'] = since
                request['endTime'] = self.sum(since,7776000000)

            if limit != None:
                request['limit'] = limit

            response = await (self).sapiGetCapitalWithdrawHistory(self.extend(request,params))
        return self.parseTransactions(response,currency,since,limit)

    def parseTransactionStatusByType(self, status, type):
        statusesByType = {
            'deposit': {
                '0': 'pending',
                '1': 'ok',
                'Processing': 'pending',
                'Failed': 'failed',
                'Successful': 'ok',
                'Refunding': 'canceled',
                'Refunded': 'canceled',
                'Refund Failed': 'failed'
            },
            'withdrawal': {
                '0': 'pending',
                '1': 'canceled',
                '2': 'pending',
                '3': 'failed',
                '4': 'pending',
                '5': 'failed',
                '6': 'ok',
                'Processing': 'pending',
                'Failed': 'failed',
                'Successful': 'ok',
                'Refunding': 'canceled',
                'Refunded': 'canceled',
                'Refund Failed': 'failed'
            }
        }
        statuses = self.safeValue(statusesByType,type,{

        })
        return self.safeString(statuses,status,status)

    def parseTransaction(self, transaction, currency):
        id = self.safeString2(transaction,'id','orderNo')
        address = self.safeString(transaction,'address')
        tag = self.safeString(transaction,'addressTag')
        if tag != None:
            if len(tag) < 1:
                tag = None


        txid = self.safeString(transaction,'txId')
        if (txid != None) and (txid.find('Internal transfer ') >= 0):
            txid = txid.slice(18)

        currencyId = self.safeString2(transaction,'coin','fiatCurrency')
        code = self.safeCurrencyCode(currencyId,currency)
        timestamp = None
        insertTime = self.safeInteger2(transaction,'insertTime','createTime')
        applyTime = self.parse8601(self.safeString(transaction,'applyTime'))
        type = self.safeString(transaction,'type')
        if type == None:
            if (insertTime != None) and (applyTime == None):
                type = 'deposit'
                timestamp = insertTime
            elif (insertTime == None) and (applyTime != None):
                type = 'withdrawal'
                timestamp = applyTime


        status = self.parseTransactionStatusByType(self.safeString(transaction,'status'),type)
        amount = self.safeNumber(transaction,'amount')
        feeCost = self.safeNumber2(transaction,'transactionFee','totalFee')
        fee = None
        if feeCost != None:
            fee = {
                'currency': code,
                'cost': feeCost
            }

        updated = self.safeInteger2(transaction,'successTime','updateTime')
        internal = self.safeInteger(transaction,'transferType')
        if internal != None:
            internal = True if internal else False

        network = self.safeString(transaction,'network')
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'network': network,
            'address': address,
            'addressTo': address,
            'addressFrom': None,
            'tag': tag,
            'tagTo': tag,
            'tagFrom': None,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': updated,
            'internal': internal,
            'fee': fee
        }

    def parseTransferStatus(self, status):
        statuses = {
            'CONFIRMED': 'ok'
        }
        return self.safeString(statuses,status,status)

    def parseTransfer(self, transfer, currency):
        id = self.safeString(transfer,'tranId')
        currencyId = self.safeString(transfer,'asset')
        code = self.safeCurrencyCode(currencyId,currency)
        amount = self.safeNumber(transfer,'amount')
        type = self.safeString(transfer,'type')
        fromAccount = None
        toAccount = None
        accountsById = self.safeValue(self.options,'accountsById',{

        })
        if type != None:
            parts = type.split('_')
            fromAccount = self.safeValue(parts,0)
            toAccount = self.safeValue(parts,1)
            fromAccount = self.safeString(accountsById,fromAccount,fromAccount)
            toAccount = self.safeString(accountsById,toAccount,toAccount)

        timestamp = self.safeInteger(transfer,'timestamp')
        status = self.parseTransferStatus(self.safeString(transfer,'status'))
        return {
            'info': transfer,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'currency': code,
            'amount': amount,
            'fromAccount': fromAccount,
            'toAccount': toAccount,
            'status': status
        }

    def parseIncome(self, income, market):
        marketId = self.safeString(income,'symbol')
        symbol = self.safeSymbol(marketId,market)
        amount = self.safeNumber(income,'income')
        currencyId = self.safeString(income,'asset')
        code = self.safeCurrencyCode(currencyId)
        id = self.safeString(income,'tranId')
        timestamp = self.safeInteger(income,'time')
        return {
            'info': income,
            'symbol': symbol,
            'code': code,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'id': id,
            'amount': amount
        }

    def parseIncomes(self, incomes, market, since, limit):
        result = []
        for i in range(0, len(incomes)):
            entry = incomes[i]
            parsed = self.parseIncome(entry,market)
            result.append(parsed)
        sorted = self.sortBy(result,'timestamp')
        return self.filterBySinceLimit(sorted,since,limit)

    async def transfer(self, code, amount, fromAccount, toAccount, params):
        await self.loadMarkets()
        currency = self.currency(code)
        request = {
            'asset': currency['id'],
            'amount': self.currencyToPrecision(code,amount)
        }
        request['type'] = self.safeString(params,'type')
        method = 'sapiPostAssetTransfer'
        if request['type'] == None:
            symbol = self.safeString(params,'symbol')
            if symbol != None:
                params = self.omit(params,'symbol')

            fromId = self.convertTypeToAccount(fromAccount).upper()
            toId = self.convertTypeToAccount(toAccount).upper()
            if fromId == 'ISOLATED':
                if symbol == None:
                    raise ArgumentsRequired(self.id + ' transfer () requires params["symbol"] when fromAccount is ' + fromAccount)
                else:
                    fromId = self.marketId(symbol)

            if toId == 'ISOLATED':
                if symbol == None:
                    raise ArgumentsRequired(self.id + ' transfer () requires params["symbol"] when toAccount is ' + toAccount)
                else:
                    toId = self.marketId(symbol)

            fromIsolated = self.inArray(fromId,self.ids)
            toIsolated = self.inArray(toId,self.ids)
            if fromIsolated or toIsolated:
                fromFuture = fromId == 'UMFUTURE' or fromId == 'CMFUTURE'
                toFuture = toId == 'UMFUTURE' or toId == 'CMFUTURE'
                fromSpot = fromId == 'MAIN'
                toSpot = toId == 'MAIN'
                funding = fromId == 'FUNDING' or toId == 'FUNDING'
                mining = fromId == 'MINING' or toId == 'MINING'
                prohibitedWithIsolated = fromFuture or toFuture or mining or funding
                if (fromIsolated or toIsolated) and prohibitedWithIsolated:
                    raise BadRequest(self.id + ' transfer () does not allow transfers between ' + fromAccount + ' and ' + toAccount)
                elif fromIsolated and toSpot:
                    method = 'sapiPostMarginIsolatedTransfer'
                    request['transFrom'] = 'ISOLATED_MARGIN'
                    request['transTo'] = 'SPOT'
                    request['symbol'] = fromId
                elif fromSpot and toIsolated:
                    method = 'sapiPostMarginIsolatedTransfer'
                    request['transFrom'] = 'SPOT'
                    request['transTo'] = 'ISOLATED_MARGIN'
                    request['symbol'] = toId
                else:
                    if self.inArray(fromId,self.ids):
                        request['fromSymbol'] = fromId
                        fromId = 'ISOLATEDMARGIN'

                    if self.inArray(toId,self.ids):
                        request['toSymbol'] = toId
                        toId = 'ISOLATEDMARGIN'

                    request['type'] = fromId + '_' + toId
            else:
                request['type'] = fromId + '_' + toId

        params = self.omit(params,'type')
        response = await getattr(self, method)(self.extend(request,params))
        transfer = self.parseTransfer(response,currency)
        return self.extend(transfer,{
            'amount': amount,
            'currency': code,
            'fromAccount': fromAccount,
            'toAccount': toAccount
        })

    async def fetchTransfers(self, code, since, limit, params):
        await self.loadMarkets()
        currency = None
        if code != None:
            currency = self.currency(code)

        defaultType = self.safeString2(self.options,'fetchTransfers','defaultType','spot')
        fromAccount = self.safeString(params,'fromAccount',defaultType)
        defaultTo = 'spot' if (fromAccount == 'future') else 'future'
        toAccount = self.safeString(params,'toAccount',defaultTo)
        type = self.safeString(params,'type')
        accountsByType = self.safeValue(self.options,'accountsByType',{

        })
        fromId = self.safeString(accountsByType,fromAccount)
        toId = self.safeString(accountsByType,toAccount)
        if type == None:
            if fromId == None:
                keys = list(accountsByType.keys())
                raise ExchangeError(self.id + ' fromAccount parameter must be one of ' + keys.join(', '))

            if toId == None:
                keys = list(accountsByType.keys())
                raise ExchangeError(self.id + ' toAccount parameter must be one of ' + keys.join(', '))

            type = fromId + '_' + toId

        request = {
            'type': type
        }
        if since != None:
            request['startTime'] = since

        if limit != None:
            request['size'] = limit

        response = await (self).sapiGetAssetTransfer(self.extend(request,params))
        rows = self.safeValue(response,'rows',[])
        return self.parseTransfers(rows,currency,since,limit)

    async def fetchDepositAddress(self, code, params):
        await self.loadMarkets()
        currency = self.currency(code)
        request = {
            'coin': currency['id']
        }
        networks = self.safeValue(self.options,'networks',{

        })
        network = self.safeStringUpper(params,'network')
        network = self.safeString(networks,network,network)
        if network != None:
            request['network'] = network
            params = self.omit(params,'network')

        response = await (self).sapiGetCapitalDepositAddress(self.extend(request,params))
        address = self.safeString(response,'address')
        url = self.safeString(response,'url')
        impliedNetwork = None
        if url != None:
            reverseNetworks = self.safeValue(self.options,'reverseNetworks',{

            })
            parts = url.split('/')
            topLevel = self.safeString(parts,2)
            if (topLevel == 'blockchair.com') or (topLevel == 'viewblock.io'):
                subLevel = self.safeString(parts,3)
                if subLevel != None:
                    topLevel = topLevel + '/' + subLevel


            impliedNetwork = self.safeString(reverseNetworks,topLevel)
            impliedNetworks = self.safeValue(self.options,'impliedNetworks',{
                'ETH': {
                    'ERC20': 'ETH'
                },
                'TRX': {
                    'TRC20': 'TRX'
                }
            })
            if code in impliedNetworks:
                conversion = self.safeValue(impliedNetworks,code,{

                })
                impliedNetwork = self.safeString(conversion,impliedNetwork,impliedNetwork)


        tag = self.safeString(response,'tag','')
        if len(tag) == 0:
            tag = None

        self.checkAddress(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'network': impliedNetwork,
            'info': response
        }

    async def fetchTransactionFees(self, codes, params):
        await self.loadMarkets()
        response = await (self).sapiGetCapitalConfigGetall(params)
        withdrawFees = {

        }
        for i in range(0, len(response)):
            entry = response[i]
            currencyId = self.safeString(entry,'coin')
            code = self.safeCurrencyCode(currencyId)
            networkList = self.safeValue(entry,'networkList',[])
            withdrawFees[code] = {

            }
            for j in range(0, len(networkList)):
                networkEntry = networkList[j]
                networkId = self.safeString(networkEntry,'network')
                networkCode = self.safeCurrencyCode(networkId)
                fee = self.safeNumber(networkEntry,'withdrawFee')
                withdrawFees[code][networkCode] = fee
        return {
            'withdraw': withdrawFees,
            'deposit': {

            },
            'info': response
        }

    async def withdraw(self, code, amount, address, tag, params):
        [tag, params] = self.handleWithdrawTagAndParams(tag,params)
        self.checkAddress(address)
        await self.loadMarkets()
        currency = self.currency(code)
        request = {
            'coin': currency['id'],
            'address': address,
            'amount': amount
        }
        if tag != None:
            request['addressTag'] = tag

        networks = self.safeValue(self.options,'networks',{

        })
        network = self.safeStringUpper(params,'network')
        network = self.safeString(networks,network,network)
        if network != None:
            request['network'] = network
            params = self.omit(params,'network')

        response = await (self).sapiPostCapitalWithdrawApply(self.extend(request,params))
        return self.parseTransaction(response,currency)

    def parseTradingFee(self, fee, market):
        marketId = self.safeString(fee,'symbol')
        symbol = self.safeSymbol(marketId)
        return {
            'info': fee,
            'symbol': symbol,
            'maker': self.safeNumber(fee,'makerCommission'),
            'taker': self.safeNumber(fee,'takerCommission')
        }

    async def fetchTradingFee(self, symbol, params):
        await self.loadMarkets()
        market = self.market(symbol)
        request = {
            'symbol': market['id']
        }
        response = await (self).sapiGetAssetTradeFee(self.extend(request,params))
        first = self.safeValue(response,0,{

        })
        return self.parseTradingFee(first)

    async def fetchTradingFees(self, params):
        await self.loadMarkets()
        method = None
        defaultType = self.safeString2(self.options,'fetchTradingFees','defaultType','future')
        type = self.safeString(params,'type',defaultType)
        query = self.omit(params,'type')
        if (type == 'spot') or (type == 'margin'):
            method = 'sapiGetAssetTradeFee'
        elif type == 'future':
            method = 'fapiPrivateGetAccount'
        elif type == 'delivery':
            method = 'dapiPrivateGetAccount'

        response = await getattr(self, method)(query)
        if (type == 'spot') or (type == 'margin'):
            result = {

            }
            for i in range(0, len(response)):
                fee = self.parseTradingFee(response[i])
                symbol = fee['symbol']
                result[symbol] = fee
            return result
        elif type == 'future':
            symbols = list(self.markets.keys())
            result = {

            }
            feeTier = self.safeInteger(response,'feeTier')
            feeTiers = self.fees[type]['trading']['tiers']
            maker = feeTiers['maker'][feeTier][1]
            taker = feeTiers['taker'][feeTier][1]
            for i in range(0, len(symbols)):
                symbol = symbols[i]
                result[symbol] = {
                    'info': {
                        'feeTier': feeTier
                    },
                    'symbol': symbol,
                    'maker': maker,
                    'taker': taker
                }
            return result
        elif type == 'delivery':
            symbols = list(self.markets.keys())
            result = {

            }
            feeTier = self.safeInteger(response,'feeTier')
            feeTiers = self.fees[type]['trading']['tiers']
            maker = feeTiers['maker'][feeTier][1]
            taker = feeTiers['taker'][feeTier][1]
            for i in range(0, len(symbols)):
                symbol = symbols[i]
                result[symbol] = {
                    'info': {
                        'feeTier': feeTier
                    },
                    'symbol': symbol,
                    'maker': maker,
                    'taker': taker
                }
            return result


    async def futuresTransfer(self, code, amount, type, params):
        if (type < 1) or (type > 4):
            raise ArgumentsRequired(self.id + ' type must be between 1 and 4')

        await self.loadMarkets()
        currency = self.currency(code)
        request = {
            'asset': currency['id'],
            'amount': amount,
            'type': type
        }
        response = await (self).sapiPostFuturesTransfer(self.extend(request,params))
        return self.parseTransfer(response,currency)

    async def fetchFundingRate(self, symbol, params):
        await self.loadMarkets()
        market = self.market(symbol)
        request = {
            'symbol': market['id']
        }
        method = None
        if market['linear']:
            method = 'fapiPublicGetPremiumIndex'
        elif market['inverse']:
            method = 'dapiPublicGetPremiumIndex'
        else:
            raise NotSupported(self.id + ' fetchFundingRate() supports linear and inverse contracts only')
        response = await getattr(self, method)(self.extend(request,params))
        if market['inverse']:
            response = response[0]

        return self.parseFundingRate(response,market)

    async def fetchFundingRateHistory(self, symbol, since, limit, params):
        await self.loadMarkets()
        request = {

        }
        method = None
        defaultType = self.safeString2(self.options,'fetchFundingRateHistory','defaultType','future')
        type = self.safeString(params,'type',defaultType)
        params = self.omit(params,'type')
        if type == 'future':
            method = 'fapiPublicGetFundingRate'
        elif type == 'delivery':
            method = 'dapiPublicGetFundingRate'

        if symbol != None:
            market = self.market(symbol)
            symbol = market['symbol']
            request['symbol'] = market['id']
            if market['linear']:
                method = 'fapiPublicGetFundingRate'
            elif market['inverse']:
                method = 'dapiPublicGetFundingRate'


        if method == None:
            raise NotSupported(self.id + ' fetchFundingRateHistory() is not supported for ' + type + ' markets')

        if since != None:
            request['startTime'] = since

        until = self.safeInteger2(params,'until','till')
        endTime = self.safeInteger(params,'endTime',until)
        params = self.omit(params,['endTime', 'till', 'until'])
        if endTime != None:
            request['endTime'] = endTime

        if limit != None:
            request['limit'] = limit

        response = await getattr(self, method)(self.extend(request,params))
        rates = []
        for i in range(0, len(response)):
            entry = response[i]
            timestamp = self.safeInteger(entry,'fundingTime')
            rates.append({
                'info': entry,
                'symbol': self.safeSymbol(self.safeString(entry,'symbol')),
                'fundingRate': self.safeNumber(entry,'fundingRate'),
                'timestamp': timestamp,
                'datetime': self.iso8601(timestamp)
            })
        sorted = self.sortBy(rates,'timestamp')
        return self.filterBySymbolSinceLimit(sorted,symbol,since,limit)

    async def fetchFundingRates(self, symbols, params):
        await self.loadMarkets()
        symbols = self.marketSymbols(symbols)
        method = None
        defaultType = self.safeString2(self.options,'fetchFundingRates','defaultType','future')
        type = self.safeString(params,'type',defaultType)
        query = self.omit(params,'type')
        if type == 'future':
            method = 'fapiPublicGetPremiumIndex'
        elif type == 'delivery':
            method = 'dapiPublicGetPremiumIndex'
        else:
            raise NotSupported(self.id + ' fetchFundingRates() supports linear and inverse contracts only')
        response = await getattr(self, method)(query)
        result = []
        for i in range(0, len(response)):
            entry = response[i]
            parsed = self.parseFundingRate(entry)
            result.append(parsed)
        return self.filterByArray(result,'symbol',symbols)

    def parseFundingRate(self, contract, market):
        timestamp = self.safeInteger(contract,'time')
        marketId = self.safeString(contract,'symbol')
        symbol = self.safeSymbol(marketId,market)
        markPrice = self.safeNumber(contract,'markPrice')
        indexPrice = self.safeNumber(contract,'indexPrice')
        interestRate = self.safeNumber(contract,'interestRate')
        estimatedSettlePrice = self.safeNumber(contract,'estimatedSettlePrice')
        fundingRate = self.safeNumber(contract,'lastFundingRate')
        fundingTime = self.safeInteger(contract,'nextFundingTime')
        return {
            'info': contract,
            'symbol': symbol,
            'markPrice': markPrice,
            'indexPrice': indexPrice,
            'interestRate': interestRate,
            'estimatedSettlePrice': estimatedSettlePrice,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fundingRate': fundingRate,
            'fundingTimestamp': fundingTime,
            'fundingDatetime': self.iso8601(fundingTime),
            'nextFundingRate': None,
            'nextFundingTimestamp': None,
            'nextFundingDatetime': None,
            'previousFundingRate': None,
            'previousFundingTimestamp': None,
            'previousFundingDatetime': None
        }

    def parseAccountPositions(self, account):
        positions = self.safeValue(account,'positions')
        assets = self.safeValue(account,'assets',[])
        balances = {

        }
        for i in range(0, len(assets)):
            entry = assets[i]
            currencyId = self.safeString(entry,'asset')
            code = self.safeCurrencyCode(currencyId)
            crossWalletBalance = self.safeString(entry,'crossWalletBalance')
            crossUnPnl = self.safeString(entry,'crossUnPnl')
            balances[code] = {
                'crossMargin': Precise.stringAdd(crossWalletBalance,crossUnPnl),
                'crossWalletBalance': crossWalletBalance
            }
        result = []
        for i in range(0, len(positions)):
            position = positions[i]
            marketId = self.safeString(position,'symbol')
            market = self.safeMarket(marketId)
            code = market['quote'] if (self.options['defaultType'] == 'future') else market['base']
            if code in balances:
                parsed = self.parseAccountPosition(self.extend(position,{
                    'crossMargin': balances[code]['crossMargin'],
                    'crossWalletBalance': balances[code]['crossWalletBalance']
                }),market)
                result.append(parsed)

        return result

    def parseAccountPosition(self, position, market):
        marketId = self.safeString(position,'symbol')
        market = self.safeMarket(marketId,market)
        symbol = self.safeString(market,'symbol')
        leverageString = self.safeString(position,'leverage')
        leverage = parseInt(leverageString)
        initialMarginString = self.safeString(position,'initialMargin')
        initialMargin = self.parseNumber(initialMarginString)
        initialMarginPercentageString = Precise.stringDiv('1',leverageString,8)
        rational = (1000 % leverage) == 0
        if notrational:
            initialMarginPercentageString = Precise.stringDiv(Precise.stringAdd(initialMarginPercentageString,'1e-8'),'1',8)

        usdm = ('notional' in position)
        maintenanceMarginString = self.safeString(position,'maintMargin')
        maintenanceMargin = self.parseNumber(maintenanceMarginString)
        entryPriceString = self.safeString(position,'entryPrice')
        entryPrice = self.parseNumber(entryPriceString)
        notionalString = self.safeString2(position,'notional','notionalValue')
        notionalStringAbs = Precise.stringAbs(notionalString)
        notional = self.parseNumber(notionalStringAbs)
        contractsString = self.safeString(position,'positionAmt')
        contractsStringAbs = Precise.stringAbs(contractsString)
        if contractsString == None:
            entryNotional = Precise.stringMul(Precise.stringMul(leverageString,initialMarginString),entryPriceString)
            contractSize = self.safeString(market,'contractSize')
            contractsString = Precise.stringDiv(entryNotional,contractSize)
            contractsStringAbs = Precise.stringDiv(Precise.stringAdd(contractsString,'0.5'),'1',0)

        contracts = self.parseNumber(contractsStringAbs)
        leverageBrackets = self.safeValue(self.options,'leverageBrackets',{

        })
        leverageBracket = self.safeValue(leverageBrackets,symbol,[])
        maintenanceMarginPercentageString = None
        for i in range(0, len(leverageBracket)):
            bracket = leverageBracket[i]
            if Precise.stringLt(notionalStringAbs,bracket[0]):
                break

            maintenanceMarginPercentageString = bracket[1]
        maintenanceMarginPercentage = self.parseNumber(maintenanceMarginPercentageString)
        unrealizedPnlString = self.safeString(position,'unrealizedProfit')
        unrealizedPnl = self.parseNumber(unrealizedPnlString)
        timestamp = self.safeInteger(position,'updateTime')
        if timestamp == 0:
            timestamp = None

        isolated = self.safeValue(position,'isolated')
        marginMode = None
        collateralString = None
        walletBalance = None
        if isolated:
            marginMode = 'isolated'
            walletBalance = self.safeString(position,'isolatedWallet')
            collateralString = Precise.stringAdd(walletBalance,unrealizedPnlString)
        else:
            marginMode = 'cross'
            walletBalance = self.safeString(position,'crossWalletBalance')
            collateralString = self.safeString(position,'crossMargin')
        collateral = self.parseNumber(collateralString)
        marginRatio = None
        side = None
        percentage = None
        liquidationPriceStringRaw = None
        liquidationPrice = None
        contractSize = self.safeValue(market,'contractSize')
        contractSizeString = self.numberToString(contractSize)
        if Precise.stringEquals(notionalString,'0'):
            entryPrice = None
        else:
            side = 'short' if Precise.stringLt(notionalString,'0') else 'long'
            marginRatio = self.parseNumber(Precise.stringDiv(Precise.stringAdd(Precise.stringDiv(maintenanceMarginString,collateralString),'5e-5'),'1',4))
            percentage = self.parseNumber(Precise.stringMul(Precise.stringDiv(unrealizedPnlString,initialMarginString,4),'100'))
            if usdm:
                onePlusMaintenanceMarginPercentageString = None
                entryPriceSignString = entryPriceString
                if side == 'short':
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd('1',maintenanceMarginPercentageString)
                else:
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd('-1',maintenanceMarginPercentageString)
                    entryPriceSignString = Precise.stringMul('-1',entryPriceSignString)
                leftSide = Precise.stringDiv(walletBalance,Precise.stringMul(contractsStringAbs,onePlusMaintenanceMarginPercentageString))
                rightSide = Precise.stringDiv(entryPriceSignString,onePlusMaintenanceMarginPercentageString)
                liquidationPriceStringRaw = Precise.stringAdd(leftSide,rightSide)
            else:
                onePlusMaintenanceMarginPercentageString = None
                entryPriceSignString = entryPriceString
                if side == 'short':
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub('1',maintenanceMarginPercentageString)
                else:
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub('-1',maintenanceMarginPercentageString)
                    entryPriceSignString = Precise.stringMul('-1',entryPriceSignString)
                size = Precise.stringMul(contractsStringAbs,contractSizeString)
                leftSide = Precise.stringMul(size,onePlusMaintenanceMarginPercentageString)
                rightSide = Precise.stringSub(Precise.stringMul(Precise.stringDiv('1',entryPriceSignString),size),walletBalance)
                liquidationPriceStringRaw = Precise.stringDiv(leftSide,rightSide)
            pricePrecision = market['precision']['price']
            pricePrecisionPlusOne = pricePrecision + 1
            pricePrecisionPlusOneString = str(pricePrecisionPlusOne)
            rounder = Precise('5e-' + pricePrecisionPlusOneString)
            rounderString = str(rounder)
            liquidationPriceRoundedString = Precise.stringAdd(rounderString,liquidationPriceStringRaw)
            truncatedLiquidationPrice = Precise.stringDiv(liquidationPriceRoundedString,'1',pricePrecision)
            if truncatedLiquidationPrice[0] == '-':
                truncatedLiquidationPrice = None

            liquidationPrice = self.parseNumber(truncatedLiquidationPrice)
        positionSide = self.safeString(position,'positionSide')
        hedged = positionSide != 'BOTH'
        return {
            'info': position,
            'id': None,
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'initialMargin': initialMargin,
            'initialMarginPercentage': self.parseNumber(initialMarginPercentageString),
            'maintenanceMargin': maintenanceMargin,
            'maintenanceMarginPercentage': maintenanceMarginPercentage,
            'entryPrice': entryPrice,
            'notional': notional,
            'leverage': self.parseNumber(leverageString),
            'unrealizedPnl': unrealizedPnl,
            'contracts': contracts,
            'contractSize': contractSize,
            'marginRatio': marginRatio,
            'liquidationPrice': liquidationPrice,
            'markPrice': None,
            'collateral': collateral,
            'marginMode': marginMode,
            'side': side,
            'hedged': hedged,
            'percentage': percentage
        }

    def parsePositionRisk(self, position, market):
        marketId = self.safeString(position,'symbol')
        market = self.safeMarket(marketId,market)
        symbol = self.safeString(market,'symbol')
        leverageBrackets = self.safeValue(self.options,'leverageBrackets',{

        })
        leverageBracket = self.safeValue(leverageBrackets,symbol,[])
        notionalString = self.safeString2(position,'notional','notionalValue')
        notionalStringAbs = Precise.stringAbs(notionalString)
        maintenanceMarginPercentageString = None
        for i in range(0, len(leverageBracket)):
            bracket = leverageBracket[i]
            if Precise.stringLt(notionalStringAbs,bracket[0]):
                break

            maintenanceMarginPercentageString = bracket[1]
        notional = self.parseNumber(notionalStringAbs)
        contractsAbs = Precise.stringAbs(self.safeString(position,'positionAmt'))
        contracts = self.parseNumber(contractsAbs)
        unrealizedPnlString = self.safeString(position,'unRealizedProfit')
        unrealizedPnl = self.parseNumber(unrealizedPnlString)
        leverageString = self.safeString(position,'leverage')
        leverage = parseInt(leverageString)
        liquidationPriceString = self.omitZero(self.safeString(position,'liquidationPrice'))
        liquidationPrice = self.parseNumber(liquidationPriceString)
        collateralString = None
        marginMode = self.safeString(position,'marginType')
        side = None
        if Precise.stringGt(notionalString,'0'):
            side = 'long'
        elif Precise.stringLt(notionalString,'0'):
            side = 'short'

        entryPriceString = self.safeString(position,'entryPrice')
        entryPrice = self.parseNumber(entryPriceString)
        contractSize = self.safeValue(market,'contractSize')
        contractSizeString = self.numberToString(contractSize)
        linear = ('notional' in position)
        if marginMode == 'cross':
            precision = self.safeValue(market,'precision',{

            })
            if linear:
                onePlusMaintenanceMarginPercentageString = None
                entryPriceSignString = entryPriceString
                if side == 'short':
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd('1',maintenanceMarginPercentageString)
                    entryPriceSignString = Precise.stringMul('-1',entryPriceSignString)
                else:
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd('-1',maintenanceMarginPercentageString)
                inner = Precise.stringMul(liquidationPriceString,onePlusMaintenanceMarginPercentageString)
                leftSide = Precise.stringAdd(inner,entryPriceSignString)
                pricePrecision = self.safeInteger(precision,'price')
                quotePrecision = self.safeInteger(precision,'quote',pricePrecision)
                if quotePrecision != None:
                    collateralString = Precise.stringDiv(Precise.stringMul(leftSide,contractsAbs),'1',quotePrecision)

            else:
                onePlusMaintenanceMarginPercentageString = None
                entryPriceSignString = entryPriceString
                if side == 'short':
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub('1',maintenanceMarginPercentageString)
                else:
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub('-1',maintenanceMarginPercentageString)
                    entryPriceSignString = Precise.stringMul('-1',entryPriceSignString)
                leftSide = Precise.stringMul(contractsAbs,contractSizeString)
                rightSide = Precise.stringSub(Precise.stringDiv('1',entryPriceSignString),Precise.stringDiv(onePlusMaintenanceMarginPercentageString,liquidationPriceString))
                basePrecision = self.safeInteger(precision,'base')
                if basePrecision != None:
                    collateralString = Precise.stringDiv(Precise.stringMul(leftSide,rightSide),'1',basePrecision)

        else:
            collateralString = self.safeString(position,'isolatedMargin')
        collateralString = '0' if (collateralString == None) else collateralString
        collateral = self.parseNumber(collateralString)
        markPrice = self.parseNumber(self.omitZero(self.safeString(position,'markPrice')))
        timestamp = self.safeInteger(position,'updateTime')
        if timestamp == 0:
            timestamp = None

        maintenanceMarginPercentage = self.parseNumber(maintenanceMarginPercentageString)
        maintenanceMarginString = Precise.stringMul(maintenanceMarginPercentageString,notionalStringAbs)
        maintenanceMargin = self.parseNumber(maintenanceMarginString)
        initialMarginPercentageString = Precise.stringDiv('1',leverageString,8)
        rational = (1000 % leverage) == 0
        if notrational:
            initialMarginPercentageString = Precise.stringAdd(initialMarginPercentageString,'1e-8')

        initialMarginString = Precise.stringDiv(Precise.stringMul(notionalStringAbs,initialMarginPercentageString),'1',8)
        initialMargin = self.parseNumber(initialMarginString)
        marginRatio = None
        percentage = None
        if notPrecise.stringEquals(collateralString,'0'):
            marginRatio = self.parseNumber(Precise.stringDiv(Precise.stringAdd(Precise.stringDiv(maintenanceMarginString,collateralString),'5e-5'),'1',4))
            percentage = self.parseNumber(Precise.stringMul(Precise.stringDiv(unrealizedPnlString,initialMarginString,4),'100'))

        positionSide = self.safeString(position,'positionSide')
        hedged = positionSide != 'BOTH'
        return {
            'info': position,
            'id': None,
            'symbol': symbol,
            'contracts': contracts,
            'contractSize': contractSize,
            'unrealizedPnl': unrealizedPnl,
            'leverage': self.parseNumber(leverageString),
            'liquidationPrice': liquidationPrice,
            'collateral': collateral,
            'notional': notional,
            'markPrice': markPrice,
            'entryPrice': entryPrice,
            'timestamp': timestamp,
            'initialMargin': initialMargin,
            'initialMarginPercentage': self.parseNumber(initialMarginPercentageString),
            'maintenanceMargin': maintenanceMargin,
            'maintenanceMarginPercentage': maintenanceMarginPercentage,
            'marginRatio': marginRatio,
            'datetime': self.iso8601(timestamp),
            'marginMode': marginMode,
            'marginType': marginMode,
            'side': side,
            'hedged': hedged,
            'percentage': percentage
        }

    async def loadLeverageBrackets(self, reload, params):
        await self.loadMarkets()
        leverageBrackets = self.safeValue(self.options,'leverageBrackets')
        if (leverageBrackets == None) or (reload):
            method = None
            defaultType = self.safeString(self.options,'defaultType','future')
            type = self.safeString(params,'type',defaultType)
            query = self.omit(params,'type')
            if type == 'future':
                method = 'fapiPrivateGetLeverageBracket'
            elif type == 'delivery':
                method = 'dapiPrivateV2GetLeverageBracket'
            else:
                raise NotSupported(self.id + ' loadLeverageBrackets() supports linear and inverse contracts only')
            response = await getattr(self, method)(query)
            self.options['leverageBrackets'] = {

            }
            for i in range(0, len(response)):
                entry = response[i]
                marketId = self.safeString(entry,'symbol')
                symbol = self.safeSymbol(marketId)
                brackets = self.safeValue(entry,'brackets',[])
                result = []
                for j in range(0, len(brackets)):
                    bracket = brackets[j]
                    floorValue = self.safeString2(bracket,'notionalFloor','qtyFloor')
                    maintenanceMarginPercentage = self.safeString(bracket,'maintMarginRatio')
                    result.append([floorValue, maintenanceMarginPercentage])
                self.options['leverageBrackets'][symbol] = result

        return self.options['leverageBrackets']

    async def fetchLeverageTiers(self, symbols, params):
        await self.loadMarkets()
        [type, query] = self.handleMarketTypeAndParams('fetchLeverageTiers',None,params)
        method = None
        if type == 'future':
            method = 'fapiPrivateGetLeverageBracket'
        elif type == 'delivery':
            method = 'dapiPrivateV2GetLeverageBracket'
        else:
            raise NotSupported(self.id + ' fetchLeverageTiers() supports linear and inverse contracts only')
        response = await getattr(self, method)(query)
        return self.parseLeverageTiers(response,symbols,'symbol')

    def parseMarketLeverageTiers(self, info, market):
        marketId = self.safeString(info,'symbol')
        market = self.safeMarket(marketId,market)
        brackets = self.safeValue(info,'brackets',[])
        tiers = []
        for j in range(0, len(brackets)):
            bracket = brackets[j]
            tiers.append({
                'tier': self.safeNumber(bracket,'bracket'),
                'currency': market['quote'],
                'minNotional': self.safeNumber2(bracket,'notionalFloor','qtyFloor'),
                'maxNotional': self.safeNumber2(bracket,'notionalCap','qtyCap'),
                'maintenanceMarginRate': self.safeNumber(bracket,'maintMarginRatio'),
                'maxLeverage': self.safeNumber(bracket,'initialLeverage'),
                'info': bracket
            })
        return tiers

    async def fetchPositions(self, symbols, params):
        defaultMethod = self.safeString(self.options,'fetchPositions','positionRisk')
        if defaultMethod == 'positionRisk':
            return await self.fetchPositionsRisk(symbols,params)
        elif defaultMethod == 'account':
            return await self.fetchAccountPositions(symbols,params)
        else:
            raise NotSupported(self.id + '.options["fetchPositions"] = "' + defaultMethod + '" is invalid, please choose between "account" and "positionRisk"')

    async def fetchAccountPositions(self, symbols, params):
        if symbols != None:
            if notisinstance(symbols, list):
                raise ArgumentsRequired(self.id + ' fetchPositions() requires an array argument for symbols')


        await self.loadMarkets()
        await self.loadLeverageBrackets(False,params)
        method = None
        defaultType = self.safeString(self.options,'defaultType','future')
        type = self.safeString(params,'type',defaultType)
        query = self.omit(params,'type')
        if type == 'future':
            method = 'fapiPrivateGetAccount'
        elif type == 'delivery':
            method = 'dapiPrivateGetAccount'
        else:
            raise NotSupported(self.id + ' fetchPositions() supports linear and inverse contracts only')
        account = await getattr(self, method)(query)
        result = self.parseAccountPositions(account)
        symbols = self.marketSymbols(symbols)
        return self.filterByArray(result,'symbol',symbols,False)

    async def fetchPositionsRisk(self, symbols, params):
        if symbols != None:
            if notisinstance(symbols, list):
                raise ArgumentsRequired(self.id + ' fetchPositionsRisk() requires an array argument for symbols')


        await self.loadMarkets()
        await self.loadLeverageBrackets(False,params)
        request = {

        }
        method = None
        defaultType = 'future'
        defaultType = self.safeString(self.options,'defaultType',defaultType)
        type = self.safeString(params,'type',defaultType)
        params = self.omit(params,'type')
        if (type == 'future') or (type == 'linear'):
            method = 'fapiPrivateGetPositionRisk'
        elif (type == 'delivery') or (type == 'inverse'):
            method = 'dapiPrivateGetPositionRisk'
        else:
            raise NotSupported(self.id + ' fetchPositionsRisk() supports linear and inverse contracts only')
        response = await getattr(self, method)(self.extend(request,params))
        result = []
        for i in range(0, len(response)):
            parsed = self.parsePositionRisk(response[i])
            result.append(parsed)
        symbols = self.marketSymbols(symbols)
        return self.filterByArray(result,'symbol',symbols,False)

    async def fetchFundingHistory(self, symbol, since, limit, params):
        await self.loadMarkets()
        market = None
        method = None
        defaultType = 'future'
        request = {
            'incomeType': 'FUNDING_FEE'
        }
        if symbol != None:
            market = self.market(symbol)
            request['symbol'] = market['id']
            if market['linear']:
                defaultType = 'future'
            elif market['inverse']:
                defaultType = 'delivery'
            else:
                raise NotSupported(self.id + ' fetchFundingHistory() supports linear and inverse contracts only')

        if since != None:
            request['startTime'] = since

        if limit != None:
            request['limit'] = limit

        defaultType = self.safeString2(self.options,'fetchFundingHistory','defaultType',defaultType)
        type = self.safeString(params,'type',defaultType)
        params = self.omit(params,'type')
        if (type == 'future') or (type == 'linear'):
            method = 'fapiPrivateGetIncome'
        elif (type == 'delivery') or (type == 'inverse'):
            method = 'dapiPrivateGetIncome'
        else:
            raise NotSupported(self.id + ' fetchFundingHistory() supports linear and inverse contracts only')
        response = await getattr(self, method)(self.extend(request,params))
        return self.parseIncomes(response,market,since,limit)

    async def setLeverage(self, leverage, symbol, params):
        if symbol == None:
            raise ArgumentsRequired(self.id + ' setLeverage() requires a symbol argument')

        if (leverage < 1) or (leverage > 125):
            raise BadRequest(self.id + ' leverage should be between 1 and 125')

        await self.loadMarkets()
        market = self.market(symbol)
        method = None
        if market['linear']:
            method = 'fapiPrivatePostLeverage'
        elif market['inverse']:
            method = 'dapiPrivatePostLeverage'
        else:
            raise NotSupported(self.id + ' setLeverage() supports linear and inverse contracts only')
        request = {
            'symbol': market['id'],
            'leverage': leverage
        }
        return await getattr(self, method)(self.extend(request,params))

    async def setMarginMode(self, marginMode, symbol, params):
        if symbol == None:
            raise ArgumentsRequired(self.id + ' setMarginMode() requires a symbol argument')

        marginMode = marginMode.upper()
        if marginMode == 'CROSS':
            marginMode = 'CROSSED'

        if (marginMode != 'ISOLATED') and (marginMode != 'CROSSED'):
            raise BadRequest(self.id + ' marginMode must be either isolated or cross')

        await self.loadMarkets()
        market = self.market(symbol)
        method = None
        if market['linear']:
            method = 'fapiPrivatePostMarginType'
        elif market['inverse']:
            method = 'dapiPrivatePostMarginType'
        else:
            raise NotSupported(self.id + ' setMarginMode() supports linear and inverse contracts only')
        request = {
            'symbol': market['id'],
            'marginType': marginMode
        }
        response = None
        try:
            response = await getattr(self, method)(self.extend(request,params))
        except Exception as e:
            if isinstance(e, MarginModeAlreadySet):
                throwMarginModeAlreadySet = self.safeValue(self.options,'throwMarginModeAlreadySet',False)
                if throwMarginModeAlreadySet:
                    raise e
                else:
                    response = {
                        'code': -4046,
                        'msg': 'No need to change margin type.'
                    }

        return response

    async def setPositionMode(self, hedged, symbol, params):
        defaultType = self.safeString(self.options,'defaultType','future')
        type = self.safeString(params,'type',defaultType)
        params = self.omit(params,['type'])
        dualSidePosition = None
        if hedged:
            dualSidePosition = 'true'
        else:
            dualSidePosition = 'false'
        request = {
            'dualSidePosition': dualSidePosition
        }
        method = None
        if type == 'delivery':
            method = 'dapiPrivatePostPositionSideDual'
        else:
            method = 'fapiPrivatePostPositionSideDual'
        return await getattr(self, method)(self.extend(request,params))

    def sign(self, path, api, method, params, headers, body):
        if not(api in self.urls['api']):
            raise NotSupported(self.id + ' does not have a testnet/sandbox URL for ' + api + ' endpoints')

        url = self.urls['api'][api]
        url += '/' + path
        if api == 'wapi':
            url += '.html'

        if path == 'historicalTrades':
            if self.apiKey:
                headers = {
                    'X-MBX-APIKEY': self.apiKey
                }
            else:
                raise AuthenticationError(self.id + ' historicalTrades endpoint requires `apiKey` credential')

        userDataStream = (path == 'userDataStream') or (path == 'listenKey')
        if userDataStream:
            if self.apiKey:
                headers = {
                    'X-MBX-APIKEY': self.apiKey,
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
                if method != 'GET':
                    body = self.urlencode(params)

            else:
                raise AuthenticationError(self.id + ' userDataStream endpoint requires `apiKey` credential')
        elif (api == 'private') or (api == 'sapi' and path != 'system/status') or (api == 'sapiV3') or (api == 'wapi' and path != 'systemStatus') or (api == 'dapiPrivate') or (api == 'dapiPrivateV2') or (api == 'fapiPrivate') or (api == 'fapiPrivateV2'):
            self.checkRequiredCredentials()
            query = None
            defaultRecvWindow = self.safeInteger(self.options,'recvWindow')
            extendedParams = self.extend({
                'timestamp': self.nonce()
            },params)
            if defaultRecvWindow != None:
                extendedParams['recvWindow'] = defaultRecvWindow

            recvWindow = self.safeInteger(params,'recvWindow')
            if recvWindow != None:
                extendedParams['recvWindow'] = recvWindow

            if (api == 'sapi') and (path == 'asset/dust'):
                query = self.urlencodeWithArrayRepeat(extendedParams)
            elif (path == 'batchOrders') or (path.find('sub-account') >= 0) or (path == 'capital/withdraw/apply') or (path.find('staking') >= 0):
                query = self.rawencode(extendedParams)
            else:
                query = self.urlencode(extendedParams)
            signature = self.hmac(self.encode(query),self.encode(self.secret))
            query += '&' + 'signature=' + signature
            headers = {
                'X-MBX-APIKEY': self.apiKey
            }
            if (method == 'GET') or (method == 'DELETE') or (api == 'wapi'):
                url += '?' + query
            else:
                body = query
                headers['Content-Type'] = 'application/x-www-form-urlencoded'
        else:
            if len(list(params.keys())):
                url += '?' + self.urlencode(params)

        return {
            'url': url,
            'method': method,
            'body': body,
            'headers': headers
        }

    def handleErrors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if (code == 418) or (code == 429):
            raise DDoSProtection(self.id + ' ' + str(code) + ' ' + reason + ' ' + body)

        if code >= 400:
            if body.find('Price * QTY is zero or less') >= 0:
                raise InvalidOrder(self.id + ' order cost = amount * price is zero or less ' + body)

            if body.find('LOT_SIZE') >= 0:
                raise InvalidOrder(self.id + ' order amount should be evenly divisible by lot size ' + body)

            if body.find('PRICE_FILTER') >= 0:
                raise InvalidOrder(self.id + ' order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) ' + body)


        if response == None:
            return 

        success = self.safeValue(response,'success',True)
        if notsuccess:
            message = self.safeString(response,'msg')
            parsedMessage = None
            if message != None:
                try:
                    parsedMessage = json.loads(message)
                except Exception as e:
                    parsedMessage = None
                if parsedMessage != None:
                    response = parsedMessage



        message = self.safeString(response,'msg')
        if message != None:
            self.throwExactlyMatchedException(self.exceptions['exact'],message,self.id + ' ' + message)
            self.throwBroadlyMatchedException(self.exceptions['broad'],message,self.id + ' ' + message)

        error = self.safeString(response,'code')
        if error != None:
            if (error == '200') or Precise.stringEquals(error,'0'):
                return None

            if (error == '-2015') and self.options['hasAlreadyAuthenticatedSuccessfully']:
                raise DDoSProtection(self.id + ' ' + body)

            feedback = self.id + ' ' + body
            if message == 'No need to change margin type.':
                raise MarginModeAlreadySet(feedback)

            self.throwExactlyMatchedException(self.exceptions['exact'],error,feedback)
            raise ExchangeError(feedback)

        if notsuccess:
            raise ExchangeError(self.id + ' ' + body)


    def calculateRateLimiterCost(self, api, method, path, params, config, context):
        if ('noCoin' in config) and not('coin' in params):
            return config['noCoin']
        elif ('noSymbol' in config) and not('symbol' in params):
            return config['noSymbol']
        elif ('noPoolId' in config) and not('poolId' in params):
            return config['noPoolId']
        elif ('byLimit' in config) and ('limit' in params):
            limit = params['limit']
            byLimit = config['byLimit']
            for i in range(0, len(byLimit)):
                entry = byLimit[i]
                if limit <= entry[0]:
                    return entry[1]


        return self.safeValue(config,'cost',1)

    async def request(self, path, api, method, params, headers, body, config, context):
        response = await (self).fetch2(path,api,method,params,headers,body,config,context)
        if (api == 'private') or (api == 'wapi'):
            self.options['hasAlreadyAuthenticatedSuccessfully'] = True

        return response

    async def modifyMarginHelper(self, symbol, amount, addOrReduce, params):
        defaultType = self.safeString(self.options,'defaultType','future')
        if defaultType == 'spot':
            defaultType = 'future'

        type = self.safeString(params,'type',defaultType)
        if (type == 'margin') or (type == 'spot'):
            raise NotSupported(self.id + ' add / reduce margin only supported with type future or delivery')

        await self.loadMarkets()
        market = self.market(symbol)
        amount = self.amountToPrecision(symbol,amount)
        request = {
            'type': addOrReduce,
            'symbol': market['id'],
            'amount': amount
        }
        method = None
        code = None
        if type == 'future':
            method = 'fapiPrivatePostPositionMargin'
            code = market['quote']
        else:
            method = 'dapiPrivatePostPositionMargin'
            code = market['base']
        response = await getattr(self, method)(self.extend(request,params))
        return self.extend(self.parseMarginModification(response,market),{
            'code': code
        })

    def parseMarginModification(self, data, market):
        rawType = self.safeInteger(data,'type')
        resultType = 'add' if (rawType == 1) else 'reduce'
        resultAmount = self.safeNumber(data,'amount')
        errorCode = self.safeString(data,'code')
        status = 'ok' if (errorCode == '200') else 'failed'
        return {
            'info': data,
            'type': resultType,
            'amount': resultAmount,
            'code': None,
            'symbol': market['symbol'],
            'status': status
        }

    async def reduceMargin(self, symbol, amount, params):
        return await self.modifyMarginHelper(symbol,amount,2,params)

    async def addMargin(self, symbol, amount, params):
        return await self.modifyMarginHelper(symbol,amount,1,params)

    async def fetchBorrowRate(self, code, params):
        await self.loadMarkets()
        currency = self.currency(code)
        request = {
            'asset': currency['id']
        }
        response = await (self).sapiGetMarginInterestRateHistory(self.extend(request,params))
        rate = self.safeValue(response,0)
        return self.parseBorrowRate(rate)

    async def fetchBorrowRateHistory(self, code, since, limit, params):
        await self.loadMarkets()
        if limit == None:
            limit = 93
        elif limit > 93:
            raise BadRequest(self.id + ' fetchBorrowRateHistory() limit parameter cannot exceed 92')

        currency = self.currency(code)
        request = {
            'asset': currency['id'],
            'limit': limit
        }
        if since != None:
            request['startTime'] = since
            endTime = self.sum(since,limit * 86400000) - 1
            now = self.milliseconds()
            request['endTime'] = Math.min(endTime,now)

        response = await (self).sapiGetMarginInterestRateHistory(self.extend(request,params))
        return (self).parseBorrowRateHistory(response)

    def parseBorrowRateHistory(self, response, code, since, limit):
        result = []
        for i in range(0, len(response)):
            item = response[i]
            borrowRate = self.parseBorrowRate(item)
            result.append(borrowRate)
        sorted = self.sortBy(result,'timestamp')
        return self.filterByCurrencySinceLimit(sorted,code,since,limit)

    def parseBorrowRate(self, info, currency):
        timestamp = self.safeNumber(info,'timestamp')
        currency = self.safeString(info,'asset')
        return {
            'currency': self.safeCurrencyCode(currency),
            'rate': self.safeNumber(info,'dailyInterestRate'),
            'period': 86400000,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'info': info
        }

    async def createGiftCode(self, code, amount, params):
        await self.loadMarkets()
        currency = self.currency(code)
        request = {
            'token': currency['id'],
            'amount': amount
        }
        response = await (self).sapiPostGiftcardCreateCode(self.extend(request,params))
        data = self.safeValue(response,'data')
        giftcardCode = self.safeString(data,'code')
        id = self.safeString(data,'referenceNo')
        return {
            'info': response,
            'id': id,
            'code': giftcardCode,
            'currency': code,
            'amount': amount
        }

    async def redeemGiftCode(self, giftcardCode, params):
        request = {
            'code': giftcardCode
        }
        response = await (self).sapiPostGiftcardRedeemCode(self.extend(request,params))
        return response

    async def verifyGiftCode(self, id, params):
        request = {
            'referenceNo': id
        }
        response = await (self).sapiGetGiftcardVerify(self.extend(request,params))
        return response

    async def fetchBorrowInterest(self, code, symbol, since, limit, params):
        await self.loadMarkets()
        request = {

        }
        market = None
        if code != None:
            currency = self.currency(code)
            request['asset'] = currency['id']

        if since != None:
            request['startTime'] = since

        if limit != None:
            request['size'] = limit

        if symbol != None:
            market = self.market(symbol)
            request['isolatedSymbol'] = market['id']

        response = await (self).sapiGetMarginInterestHistory(self.extend(request,params))
        rows = self.safeValue(response,'rows')
        interest = self.parseBorrowInterests(rows,market)
        return self.filterByCurrencySinceLimit(interest,code,since,limit)

    def parseBorrowInterest(self, info, market):
        symbol = self.safeString(info,'isolatedSymbol')
        timestamp = self.safeNumber(info,'interestAccuredTime')
        marginMode = 'cross' if (symbol == None) else 'isolated'
        return {
            'account': 'cross' if (symbol == None) else symbol,
            'symbol': symbol,
            'marginMode': marginMode,
            'currency': self.safeCurrencyCode(self.safeString(info,'asset')),
            'interest': self.safeNumber(info,'interest'),
            'interestRate': self.safeNumber(info,'interestRate'),
            'amountBorrowed': self.safeNumber(info,'principal'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'info': info
        }

    async def repayMargin(self, code, amount, symbol, params):
        await self.loadMarkets()
        market = None
        if symbol != None:
            market = self.market(symbol)
            symbol = market['symbol']

        currency = self.currency(code)
        request = {
            'asset': currency['id'],
            'amount': self.currencyToPrecision(code,amount)
        }
        defaultMarginMode = self.safeString2(self.options,'defaultMarginMode','marginMode','cross')
        marginMode = self.safeString(params,'marginMode',defaultMarginMode)
        if marginMode == 'isolated':
            if symbol == None:
                raise ArgumentsRequired(self.id + ' repayMargin() requires a symbol argument for isolated margin')

            request['isIsolated'] = 'TRUE'
            request['symbol'] = market['id']

        params = self.omit(params,'marginMode')
        response = await (self).sapiPostMarginRepay(self.extend(request,params))
        transaction = self.parseMarginLoan(response,currency)
        return self.extend(transaction,{
            'amount': amount,
            'symbol': symbol
        })

    async def borrowMargin(self, code, amount, symbol, params):
        await self.loadMarkets()
        market = None
        if symbol != None:
            market = self.market(symbol)
            symbol = market['symbol']

        currency = self.currency(code)
        request = {
            'asset': currency['id'],
            'amount': self.currencyToPrecision(code,amount)
        }
        defaultMarginMode = self.safeString2(self.options,'defaultMarginMode','marginMode','cross')
        marginMode = self.safeString(params,'marginMode',defaultMarginMode)
        if marginMode == 'isolated':
            if symbol == None:
                raise ArgumentsRequired(self.id + ' borrowMargin() requires a symbol argument for isolated margin')

            request['isIsolated'] = 'TRUE'
            request['symbol'] = market['id']

        params = self.omit(params,'marginMode')
        response = await (self).sapiPostMarginLoan(self.extend(request,params))
        transaction = self.parseMarginLoan(response,currency)
        return self.extend(transaction,{
            'amount': amount,
            'symbol': symbol
        })

    def parseMarginLoan(self, info, currency):
        return {
            'id': self.safeInteger(info,'tranId'),
            'currency': self.safeCurrencyCode(None,currency),
            'amount': None,
            'symbol': None,
            'timestamp': None,
            'datetime': None,
            'info': info
        }

    async def fetchOpenInterestHistory(self, symbol, timeframe, since, limit, params):
        if timeframe == '1m':
            raise BadRequest(self.id + 'fetchOpenInterestHistory cannot use the 1m timeframe')

        await self.loadMarkets()
        market = self.market(symbol)
        request = {
            'period': self.timeframes[timeframe]
        }
        if limit != None:
            request['limit'] = limit

        symbolKey = 'symbol' if market['linear'] else 'pair'
        request[symbolKey] = market['id']
        if market['delivery']:
            request['contractType'] = self.safeString(params,'contractType','CURRENT_QUARTER')

        if since != None:
            request['startTime'] = since

        until = self.safeInteger2(params,'until','till')
        endTime = self.safeInteger(params,'endTime',until)
        params = self.omit(params,['endTime', 'until', 'till'])
        if endTime:
            request['endTime'] = endTime
        elif since:
            if limit == None:
                limit = 30

            duration = self.parseTimeframe(timeframe)
            request['endTime'] = self.sum(since,duration * limit * 1000)

        method = 'fapiDataGetOpenInterestHist'
        if market['inverse']:
            method = 'dapiDataGetOpenInterestHist'

        response = await getattr(self, method)(self.extend(request,params))
        return self.parseOpenInterests(response,symbol,since,limit)

    def parseOpenInterest(self, interest, market):
        timestamp = self.safeInteger(interest,'timestamp')
        id = self.safeString(interest,'symbol')
        market = self.safeMarket(id,market)
        return {
            'symbol': self.safeSymbol(id),
            'baseVolume': self.safeNumber(interest,'sumOpenInterest'),
            'quoteVolume': self.safeNumber(interest,'sumOpenInterestValue'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'info': interest
        }

